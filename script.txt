//@version=6
indicator("Palantir Strategy: Ultimate Master Guard V10", overlay=true, max_labels_count=500)

// ============================================================================
// INPUTS
// ============================================================================
int smaFast          = input.int(50,    "Momentum Line (50)",             minval=1)
int smaSlow          = input.int(200,   "Trend Line (200)",              minval=1)
float volThreshold   = input.float(1.5, "Volume Trigger (x Average)",    minval=1.1)
int baseLookback     = input.int(50,    "Base Lookback Period (Bars)",    minval=20)
int probLookback     = input.int(20,    "Volatility Forecast Period",    minval=5)
string compSymbol    = input.symbol("URTH", "Comparison Symbol (RS)")
int cooldownBars     = input.int(10,    "Signal Cooldown (Bars)",        minval=1)
int adxLen           = input.int(14,    "ADX Length",                    minval=5)
float adxThreshold   = input.float(20,  "ADX Trend Threshold",          minval=10)
int rsiLen           = input.int(14,    "RSI Length",                    minval=5)
float rsiOB          = input.float(75,  "RSI Overbought Level",         minval=60, maxval=95)
int atrLen           = input.int(14,    "ATR Length",                    minval=5)
bool showForecast    = input.bool(true, "Show P/FCF Price Forecast Lines")
float sharesInput    = input.float(0, "Shares Outstanding (B) — 0=auto", minval=0, tooltip="Enter shares in billions (e.g. 7.43 for MSFT). Set 0 to auto-detect via TOTAL_REVENUE/Revenue-per-share proxy.")

// ============================================================================
// DATA REQUESTS (Global Scope)
// ============================================================================
// --- Fundamental: Net Income ---
float netIncomeFQ = request.financial(syminfo.tickerid, "NET_INCOME", "FQ")
float netIncomeFY = request.financial(syminfo.tickerid, "NET_INCOME", "FY")
float netIncome   = not na(netIncomeFQ) ? netIncomeFQ : netIncomeFY
bool isGAAPProfit = nz(netIncome) > 0

// --- Fundamental: FCF & Revenue via 12M timeframe for true yearly offsets ---
float fcfAnnual = request.financial(syminfo.tickerid, "FREE_CASH_FLOW", "FY")

fcfYearly() => request.financial(syminfo.tickerid, "FREE_CASH_FLOW", "FY")
revYearly() => request.financial(syminfo.tickerid, "TOTAL_REVENUE", "FY")

[fcfY0_y, fcfY1_y, fcfY2_y, fcfY3_y, fcfY4_y] = request.security(syminfo.tickerid, "12M", [fcfYearly(), fcfYearly()[1], fcfYearly()[2], fcfYearly()[3], fcfYearly()[4]])
[revY0_y, revY1_y, revY2_y, revY3_y, revY4_y] = request.security(syminfo.tickerid, "12M", [revYearly(), revYearly()[1], revYearly()[2], revYearly()[3], revYearly()[4]])

// --- Shares Outstanding: EPS-based derivation ---
// shares = Net Income / EPS → avoids unreliable request.financial fields
float epsFY  = request.financial(syminfo.tickerid, "EARNINGS_PER_SHARE", "FY")
float niFY   = request.financial(syminfo.tickerid, "NET_INCOME", "FY")

// Derive shares: if user provided manual input, use that; otherwise derive from NI/EPS
float sharesOutAuto = not na(niFY) and not na(epsFY) and epsFY != 0 ? math.abs(niFY / epsFY) : na
float sharesOut     = sharesInput > 0 ? sharesInput * 1000000000 : sharesOutAuto

// --- Comparison data for Relative Strength ---
float compClose = request.security(compSymbol, timeframe.period, close)

// --- Weekly trend confirmation ---
float weeklyMA50  = request.security(syminfo.tickerid, "W", ta.sma(close, 10))
float weeklyMA200 = request.security(syminfo.tickerid, "W", ta.sma(close, 40))
bool weeklyBullish = not na(weeklyMA50) and not na(weeklyMA200) and weeklyMA50 > weeklyMA200

// ============================================================================
// FUNDAMENTAL ANALYSIS (with fallback logic)
// ============================================================================

// --- Helper: CAGR with cascading fallback ---
growthCAGR(float current, float y1, float y2, float y3, float y4) =>
    float cagr = na
    string period = "N/A"
    if not na(current) and not na(y4) and y4 > 0 and current > 0
        cagr := (math.pow(current / y4, 1.0 / 4.0) - 1) * 100
        period := "4Y"
    else if not na(current) and not na(y3) and y3 > 0 and current > 0
        cagr := (math.pow(current / y3, 1.0 / 3.0) - 1) * 100
        period := "3Y"
    else if not na(current) and not na(y2) and y2 > 0 and current > 0
        cagr := (math.pow(current / y2, 1.0 / 2.0) - 1) * 100
        period := "2Y"
    else if not na(current) and not na(y1) and y1 > 0 and current > 0
        cagr := ((current / y1) - 1) * 100
        period := "1Y"
    else if not na(current)
        float baseVal = not na(y4) ? y4 : (not na(y3) ? y3 : (not na(y2) ? y2 : (not na(y1) ? y1 : na)))
        if not na(baseVal)
            if baseVal <= 0 and current > 0
                cagr := 100.0
                period := "TURNAROUND"
            else if baseVal > 0 and current <= 0
                cagr := -100.0
                period := "DETERIORATING"
    [cagr, period]

// --- Revenue Growth ---
[revCAGR, revPeriod] = growthCAGR(revY0_y, revY1_y, revY2_y, revY3_y, revY4_y)
bool revValid = not na(revCAGR)
string revTrend = "NO DATA"
color revColor = color.gray
if revValid
    if revCAGR > 10
        revTrend := "GROWING " + revPeriod + " (+" + str.tostring(revCAGR, "#.#") + "%)"
        revColor := color.green
    else if revCAGR < -10
        revTrend := "DECLINING " + revPeriod + " (" + str.tostring(revCAGR, "#.#") + "%)"
        revColor := color.red
    else
        revTrend := "STABLE " + revPeriod + " (" + str.tostring(revCAGR, "#.#") + "%)"
        revColor := color.blue

// --- FCF Growth ---
[fcfCAGR, fcfPeriod] = growthCAGR(fcfY0_y, fcfY1_y, fcfY2_y, fcfY3_y, fcfY4_y)
bool fcfValid = not na(fcfCAGR)
string fcfTrend = "NO DATA"
color fcfColor = color.gray
if fcfValid
    if fcfCAGR > 10
        fcfTrend := "GROWING " + fcfPeriod + " (+" + str.tostring(fcfCAGR, "#.#") + "%)"
        fcfColor := color.green
    else if fcfCAGR < -10
        fcfTrend := "DECLINING " + fcfPeriod + " (" + str.tostring(fcfCAGR, "#.#") + "%)"
        fcfColor := color.red
    else
        fcfTrend := "STABLE " + fcfPeriod + " (" + str.tostring(fcfCAGR, "#.#") + "%)"
        fcfColor := color.blue

// ============================================================================
// P/FCF PRICE FORECAST
// ============================================================================

// --- FCF per share for each year ---
bool hasShares = not na(sharesOut) and sharesOut > 0
float fcfPS0 = hasShares and not na(fcfY0_y) and fcfY0_y > 0 ? fcfY0_y / sharesOut : na
float fcfPS1 = hasShares and not na(fcfY1_y) and fcfY1_y > 0 ? fcfY1_y / sharesOut : na
float fcfPS2 = hasShares and not na(fcfY2_y) and fcfY2_y > 0 ? fcfY2_y / sharesOut : na
float fcfPS3 = hasShares and not na(fcfY3_y) and fcfY3_y > 0 ? fcfY3_y / sharesOut : na
float fcfPS4 = hasShares and not na(fcfY4_y) and fcfY4_y > 0 ? fcfY4_y / sharesOut : na

// --- Current P/FCF ---
float currentPFCF = not na(fcfPS0) and fcfPS0 > 0 ? close / fcfPS0 : na

// --- Historical P/FCF from yearly snapshots ---
// Since we can't get historical prices per year easily, we use a proxy:
// Assume current P/FCF as Y0, and derive past P/FCFs from FCF growth ratios
// P/FCF_Yn = (Price_Yn × Shares) / FCF_Yn — but we don't have Price_Yn
// Alternative: use the current P/FCF and the FCF ratios to establish a range
// 
// Better approach: just use the FCF/share values to define the valuation band
// and apply a reasonable P/FCF multiple range from the current ratio
float pfcfCurrent = currentPFCF

// --- Build P/FCF range: use sector-aware bands ---
// Conservative: use 50% of current multiple (mean reversion bear case)
// Optimistic: use 150% of current multiple (expansion bull case)  
// But better: use the FCF per share growth to compute implied multiples
// at different price levels from history

// Most robust: Use current P/FCF with ±1 standard deviation band
// from how P/FCF would have looked at different FCF levels
float pfcfMin = na
float pfcfMax = na
float pfcfAvg = na

// Calculate what P/FCF would be at current price for each year's FCF
// This shows us the range the market has implicitly valued
float ipfcf0 = not na(fcfPS0) and fcfPS0 > 0 ? close / fcfPS0 : na
float ipfcf1 = not na(fcfPS1) and fcfPS1 > 0 ? close / fcfPS1 : na
float ipfcf2 = not na(fcfPS2) and fcfPS2 > 0 ? close / fcfPS2 : na
float ipfcf3 = not na(fcfPS3) and fcfPS3 > 0 ? close / fcfPS3 : na
float ipfcf4 = not na(fcfPS4) and fcfPS4 > 0 ? close / fcfPS4 : na

// Aggregate stats
addPFCF(float val, float currentSum, float currentMin, float currentMax, int currentCount) =>
    float newSum   = currentSum
    float newMin   = currentMin
    float newMax   = currentMax
    int   newCount = currentCount
    if not na(val) and val > 0
        newSum   := currentSum + val
        newMin   := na(currentMin) ? val : math.min(currentMin, val)
        newMax   := na(currentMax) ? val : math.max(currentMax, val)
        newCount := currentCount + 1
    [newSum, newMin, newMax, newCount]

[s1, mn1, mx1, c1] = addPFCF(ipfcf0, 0.0,  na, na, 0)
[s2, mn2, mx2, c2] = addPFCF(ipfcf1, s1, mn1, mx1, c1)
[s3, mn3, mx3, c3] = addPFCF(ipfcf2, s2, mn2, mx2, c2)
[s4, mn4, mx4, c4] = addPFCF(ipfcf3, s3, mn3, mx3, c3)
[s5, mn5, mx5, c5] = addPFCF(ipfcf4, s4, mn4, mx4, c4)

pfcfAvg := c5 > 0 ? s5 / c5 : na
pfcfMin := mn5
pfcfMax := mx5

bool forecastValid = not na(pfcfAvg) and not na(fcfCAGR) and not na(fcfPS0) and fcfPS0 > 0

// --- Project FCF per share 1 year forward ---
float fcfGrowthRate  = fcfValid ? fcfCAGR / 100.0 : 0.0
float fcfPerShareFwd = forecastValid ? fcfPS0 * (1 + fcfGrowthRate) : na

// --- Price Targets ---
float priceBear = forecastValid ? fcfPerShareFwd * pfcfMin : na
float priceFair = forecastValid ? fcfPerShareFwd * pfcfAvg : na
float priceBull = forecastValid ? fcfPerShareFwd * pfcfMax : na

// --- Upside/Downside % ---
float upsideBear = forecastValid and close > 0 ? ((priceBear / close) - 1) * 100 : na
float upsideFair = forecastValid and close > 0 ? ((priceFair / close) - 1) * 100 : na
float upsideBull = forecastValid and close > 0 ? ((priceBull / close) - 1) * 100 : na

// --- Fundamental Score (0-5) ---
int fundScore = 0
if isGAAPProfit
    fundScore += 1
if not na(fcfAnnual) and fcfAnnual > 0
    fundScore += 1
if fcfValid and fcfCAGR > 5
    fundScore += 1
if revValid and revCAGR > 5
    fundScore += 1
if not na(epsFY) and epsFY > 0
    fundScore += 1

string fundGrade = fundScore >= 5 ? "A+" : (fundScore >= 4 ? "A" : (fundScore >= 3 ? "B" : (fundScore >= 2 ? "C" : "D")))
color fundGradeColor = fundScore >= 4 ? color.green : (fundScore >= 3 ? color.blue : (fundScore >= 2 ? color.orange : color.red))

// ============================================================================
// TECHNICAL CALCULATIONS
// ============================================================================
float ma50        = ta.sma(close, smaFast)
float ma200       = ta.sma(close, smaSlow)
float avgVol      = ta.sma(volume, 50)
float highestHigh = ta.highest(high, baseLookback)
float lowestLow   = ta.lowest(low, baseLookback)
float atrVal      = ta.atr(atrLen)
float rsiVal      = ta.rsi(close, rsiLen)

// --- ADX Calculation ---
float trueRange  = ta.tr(true)
float dmPlus     = math.max(high - high[1], 0)
float dmMinus    = math.max(low[1] - low, 0)
float dmPClean   = dmPlus > dmMinus ? dmPlus : 0.0
float dmMClean   = dmMinus > dmPlus ? dmMinus : 0.0
float smTR       = ta.rma(trueRange, adxLen)
float smDMPlus   = ta.rma(dmPClean, adxLen)
float smDMMinus  = ta.rma(dmMClean, adxLen)
float diPlus     = smTR > 0 ? (smDMPlus / smTR) * 100 : 0.0
float diMinus    = smTR > 0 ? (smDMMinus / smTR) * 100 : 0.0
float diSum      = diPlus + diMinus
float dx         = diSum > 0 ? math.abs(diPlus - diMinus) / diSum * 100 : 0.0
float adxVal     = ta.rma(dx, adxLen)
bool isTrending  = adxVal > adxThreshold

// --- Relative Strength (RS) Analysis ---
float prevClose     = close[20]
float prevCompClose = compClose[20]
bool rsDataValid    = not na(compClose) and not na(prevCompClose) and not na(prevClose) and prevClose > 0 and prevCompClose > 0
float symbolPerf    = rsDataValid ? (close - prevClose) / prevClose : 0.0
float compPerf      = rsDataValid ? (compClose - prevCompClose) / prevCompClose : 0.0
bool isRSStrong     = rsDataValid and symbolPerf > compPerf

// --- Probability Forecast (Next 5 Days) ---
float logReturn       = math.log(close / nz(close[1], close))
float logStdDev       = ta.stdev(logReturn, probLookback)
float expectedMovePct = logStdDev * math.sqrt(5) * 100
float expectedMove    = close * logStdDev * math.sqrt(5)

float distToMA50 = close - ma50
float warnProb   = distToMA50 > 0 ? math.min(100, (expectedMove / distToMA50) * 50) : (na(distToMA50) ? na : 100.0)

float distToHigh = highestHigh - close
float entryProb  = distToHigh > 0 ? math.min(100, (expectedMove / distToHigh) * 50) : (na(distToHigh) ? na : 0.0)

// --- Smart Volume Logic ---
bool ma50Rising  = ma50 > ma50[5]
float maxVol5    = ta.highest(volume, 5)
bool isHighVol   = maxVol5 > avgVol * volThreshold
string volStatus = "STABLE"
color volColor   = color.blue
if isHighVol
    if close > close[1] and close > ma50
        volStatus := "ACCUMULATION"
        volColor := color.green
    else
        volStatus := "DISTRIBUTION"
        volColor := color.red

// --- Distance to MAs in % ---
float distToMA50Pct  = ma50 > 0  ? ((close - ma50) / ma50) * 100   : na
float distToMA200Pct = ma200 > 0 ? ((close - ma200) / ma200) * 100 : na

// --- MA50 color: position relative to MA200 ---
color ma50Color = ma50 > ma200 ? color.blue : color.orange

// --- Suggested Stop Loss ---
float stopATR   = close - (atrVal * 2)
float stopBase  = lowestLow
float stopLevel = math.max(stopATR, stopBase)

// --- Risk/Reward Ratio ---
float riskPerShare   = close - stopLevel
float rewardPerShare = highestHigh - close
float rrRatio        = riskPerShare > 0 ? rewardPerShare / riskPerShare : na

// ============================================================================
// SIGNALS (with cooldown & filters)
// ============================================================================
bool rawEntry   = ta.crossover(close, highestHigh[1]) and volume > avgVol * 1.2 and close > ma50 and close > ma200
bool rawWarning = ta.crossunder(close, ma50) and volume > avgVol * 1.1

bool filteredEntry   = rawEntry and isGAAPProfit and isTrending and rsiVal < rsiOB and weeklyBullish
bool filteredWarning = rawWarning

var int lastEntryBar   = na
var int lastWarningBar = na

bool entryCooldownOk   = na(lastEntryBar)   or (bar_index - lastEntryBar)   >= cooldownBars
bool warningCooldownOk = na(lastWarningBar) or (bar_index - lastWarningBar) >= cooldownBars

bool entrySignal   = filteredEntry   and entryCooldownOk
bool warningSignal = filteredWarning and warningCooldownOk

if entrySignal
    lastEntryBar := bar_index
if warningSignal
    lastWarningBar := bar_index

// ============================================================================
// VISUALIZATION
// ============================================================================
bool isBase = (highestHigh - lowestLow) < lowestLow * 0.15
bgcolor(isBase ? color.new(color.gray, 90) : na)

plot(ma50, color=ma50Rising ? ma50Color : color.red, linewidth=2, title="50 SMA")
plot(ma200, color=color.white, linewidth=3, title="200 SMA")
plot(stopLevel, color=color.new(color.red, 60), linewidth=1, style=plot.style_cross, title="Suggested Stop")

// --- P/FCF Forecast Lines ---
plot(showForecast and forecastValid ? priceBull : na, color=color.new(color.green, 40), linewidth=1, style=plot.style_line, title="Bull Target (1Y)")
plot(showForecast and forecastValid ? priceFair : na, color=color.new(color.yellow, 40), linewidth=2, style=plot.style_line, title="Fair Value (1Y)")
plot(showForecast and forecastValid ? priceBear : na, color=color.new(color.red, 40),   linewidth=1, style=plot.style_line, title="Bear Target (1Y)")

plotshape(entrySignal,   title="ENTRY",   style=shape.labelup,   location=location.belowbar, color=color.green, text="ENTRY",   textcolor=color.white, size=size.small)
plotshape(warningSignal, title="WARNING", style=shape.labeldown, location=location.abovebar, color=color.red,   text="WARNING", textcolor=color.white, size=size.small)

// ============================================================================
// DASHBOARD
// ============================================================================
var table masterTable = table.new(position.top_right, 2, 21, bgcolor=color.new(color.black, 70), border_width=1, border_color=color.gray)

if barstate.islast
    color wColor  = warnProb > 70 ? color.red : (warnProb > 40 ? color.orange : color.green)
    color eColor  = entryProb > 70 ? color.green : (entryProb > 40 ? color.orange : color.red)
    color rsColor = isRSStrong ? color.green : color.red

    int row = 0

    // --- SECTION: Fundamentals ---
    table.cell(masterTable, 0, row, "FUND. GRADE", text_color=color.white)
    table.cell(masterTable, 1, row, fundGrade + " (" + str.tostring(fundScore) + "/5)", bgcolor=fundGradeColor, text_color=color.white)
    row += 1

    table.cell(masterTable, 0, row, "GAAP PROFIT", text_color=color.white)
    table.cell(masterTable, 1, row, isGAAPProfit ? "YES (" + str.tostring(netIncome / 1000000, "#.#") + "M)" : "NO", bgcolor=isGAAPProfit ? color.green : color.red, text_color=color.white)
    row += 1

    color epsColor = not na(epsFY) and epsFY > 0 ? color.green : color.red
    table.cell(masterTable, 0, row, "EPS (FY)", text_color=color.white)
    table.cell(masterTable, 1, row, not na(epsFY) ? str.tostring(epsFY, "#.##") : "N/A", bgcolor=not na(epsFY) ? epsColor : color.gray, text_color=color.white)
    row += 1

    table.cell(masterTable, 0, row, "REVENUE", text_color=color.white)
    table.cell(masterTable, 1, row, revTrend, bgcolor=revColor, text_color=color.white)
    row += 1

    table.cell(masterTable, 0, row, "FCF TREND", text_color=color.white)
    table.cell(masterTable, 1, row, fcfTrend, bgcolor=fcfColor, text_color=color.white)
    row += 1

    // --- SECTION: P/FCF Valuation ---
    color pfcfNowColor = not na(currentPFCF) and not na(pfcfAvg) ? (currentPFCF < pfcfAvg ? color.green : color.orange) : color.gray
    table.cell(masterTable, 0, row, "P/FCF (NOW)", text_color=color.white)
    table.cell(masterTable, 1, row, not na(currentPFCF) ? str.tostring(currentPFCF, "#.#") + "x" : "N/A", bgcolor=pfcfNowColor, text_color=color.white)
    row += 1

    table.cell(masterTable, 0, row, "P/FCF (RANGE)", text_color=color.white)
    table.cell(masterTable, 1, row, not na(pfcfAvg) ? str.tostring(pfcfMin, "#.#") + " | " + str.tostring(pfcfAvg, "#.#") + " | " + str.tostring(pfcfMax, "#.#") : "N/A", bgcolor=color.gray, text_color=color.white)
    row += 1

    // --- SECTION: 1Y Price Forecast ---
    color bearColor = not na(upsideBear) ? (upsideBear > 0 ? color.green : color.red) : color.gray
    color fairColor = not na(upsideFair) ? (upsideFair > 0 ? color.green : color.red) : color.gray
    color bullColor = not na(upsideBull) ? (upsideBull > 0 ? color.green : color.red) : color.gray

    table.cell(masterTable, 0, row, "1Y BEAR", text_color=color.white)
    table.cell(masterTable, 1, row, forecastValid ? str.tostring(priceBear, "#.##") + " (" + str.tostring(upsideBear, "#.#") + "%)" : "N/A", bgcolor=bearColor, text_color=color.white)
    row += 1

    table.cell(masterTable, 0, row, "1Y FAIR", text_color=color.white)
    table.cell(masterTable, 1, row, forecastValid ? str.tostring(priceFair, "#.##") + " (" + str.tostring(upsideFair, "#.#") + "%)" : "N/A", bgcolor=fairColor, text_color=color.white)
    row += 1

    table.cell(masterTable, 0, row, "1Y BULL", text_color=color.white)
    table.cell(masterTable, 1, row, forecastValid ? str.tostring(priceBull, "#.##") + " (" + str.tostring(upsideBull, "#.#") + "%)" : "N/A", bgcolor=bullColor, text_color=color.white)
    row += 1

    // --- SECTION: Technicals ---
    table.cell(masterTable, 0, row, "TREND", text_color=color.white)
    table.cell(masterTable, 1, row, ma50Rising ? "BULLISH" : "BEARISH", bgcolor=ma50Rising ? color.green : color.red, text_color=color.white)
    row += 1

    table.cell(masterTable, 0, row, "WEEKLY TREND", text_color=color.white)
    table.cell(masterTable, 1, row, weeklyBullish ? "BULLISH" : "BEARISH", bgcolor=weeklyBullish ? color.green : color.red, text_color=color.white)
    row += 1

    color adxColor = isTrending ? color.green : color.gray
    table.cell(masterTable, 0, row, "ADX (TREND)", text_color=color.white)
    table.cell(masterTable, 1, row, str.tostring(adxVal, "#.#") + (isTrending ? " TRENDING" : " CHOPPY"), bgcolor=adxColor, text_color=color.white)
    row += 1

    color rsiColor  = rsiVal > rsiOB ? color.red : (rsiVal < 30 ? color.green : color.blue)
    string rsiLabel = rsiVal > rsiOB ? " OVERBOUGHT" : (rsiVal < 30 ? " OVERSOLD" : "")
    table.cell(masterTable, 0, row, "RSI", text_color=color.white)
    table.cell(masterTable, 1, row, str.tostring(rsiVal, "#.#") + rsiLabel, bgcolor=rsiColor, text_color=color.white)
    row += 1

    table.cell(masterTable, 0, row, "VOLUME", text_color=color.white)
    table.cell(masterTable, 1, row, volStatus, bgcolor=volColor, text_color=color.white)
    row += 1

    table.cell(masterTable, 0, row, "RS vs " + compSymbol, text_color=color.white)
    table.cell(masterTable, 1, row, rsDataValid ? (isRSStrong ? "STRONGER" : "WEAKER") : "NO DATA", bgcolor=rsDataValid ? rsColor : color.gray, text_color=color.white)
    row += 1

    // --- SECTION: Probabilities ---
    table.cell(masterTable, 0, row, "PROB. WARNING (5d)", text_color=color.white)
    table.cell(masterTable, 1, row, str.tostring(warnProb, "#.##") + "%", bgcolor=wColor, text_color=color.white)
    row += 1

    table.cell(masterTable, 0, row, "PROB. ENTRY (5d)", text_color=color.white)
    table.cell(masterTable, 1, row, str.tostring(entryProb, "#.##") + "%", bgcolor=eColor, text_color=color.white)
    row += 1

    // --- SECTION: Risk ---
    color d50Color = distToMA50Pct > 0 ? color.green : color.red
    table.cell(masterTable, 0, row, "DIST. TO MA50", text_color=color.white)
    table.cell(masterTable, 1, row, str.tostring(distToMA50Pct, "#.##") + "%", bgcolor=d50Color, text_color=color.white)
    row += 1

    color d200Color = distToMA200Pct > 0 ? color.green : color.red
    table.cell(masterTable, 0, row, "DIST. TO MA200", text_color=color.white)
    table.cell(masterTable, 1, row, str.tostring(distToMA200Pct, "#.##") + "%", bgcolor=d200Color, text_color=color.white)
    row += 1

    table.cell(masterTable, 0, row, "STOP / R:R", text_color=color.white)
    string rrText = not na(rrRatio) and rrRatio > 0 ? str.tostring(stopLevel, "#.##") + " | 1:" + str.tostring(rrRatio, "#.#") : str.tostring(stopLevel, "#.##") + " | N/A"
    color rrColor = not na(rrRatio) and rrRatio >= 2 ? color.green : (not na(rrRatio) and rrRatio >= 1 ? color.orange : color.red)
    table.cell(masterTable, 1, row, rrText, bgcolor=rrColor, text_color=color.white)