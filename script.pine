//@version=6
indicator("Palantir Strategy: Ultimate Master Guard V13", overlay=true, max_labels_count=500)

// ============================================================================
// INPUTS
// ============================================================================
int smaFast          = input.int(50,    "Momentum Line (50)",             minval=1)
int smaSlow          = input.int(200,   "Trend Line (200)",              minval=1)
float volThreshold   = input.float(1.5, "Volume Trigger (x Average)",    minval=1.1)
int baseLookback     = input.int(50,    "Base Lookback Period (Bars)",    minval=20)
int probLookback     = input.int(20,    "Volatility Forecast Period",    minval=5)
string compSymbol    = input.symbol("URTH", "Comparison Symbol (RS)")
int cooldownBars     = input.int(10,    "Signal Cooldown (Bars)",        minval=1)
int adxLen           = input.int(14,    "ADX Length",                    minval=5)
float adxThreshold   = input.float(20,  "ADX Trend Threshold",          minval=10)
int rsiLen           = input.int(14,    "RSI Length",                    minval=5)
float rsiOB          = input.float(75,  "RSI Overbought Level",         minval=60, maxval=95)
int atrLen           = input.int(14,    "ATR Length",                    minval=5)
bool showForecast    = input.bool(true, "Show P/FCF Price Forecast Lines")
float sharesInput    = input.float(0, "Shares Outstanding (B) â€” 0=auto", minval=0, tooltip="Enter shares in billions. Set 0 to auto-detect.")
int rotationLookback = input.int(60, "Sector Rotation Lookback (Days)", minval=20, maxval=120)
bool useQuarterlyFCF = input.bool(true, "Use Quarterly FCF Annualization (Cyclicals)", tooltip="When the most recent quarter's annualized FCF significantly exceeds trailing annual FCF, use the quarterly run-rate instead. Better for cyclical stocks in upswings.")
float cyclicalThreshold = input.float(50, "Cyclical Boom Threshold (Rev CAGR %)", minval=30, maxval=100, tooltip="Revenue or FCF CAGR above this level flags the stock as in a cyclical boom phase.")
bool isLumpy         = input.bool(false, "Lumpy Cash Flow Override", tooltip="Check this for companies with massive but infrequent product deliveries to disable QTRx4.")

// ============================================================================
// DATA REQUESTS (Global Scope)
// ============================================================================

// --- Core financial data (deduplicated & upgraded to TTM) ---
float niFY   = request.financial(syminfo.tickerid, "NET_INCOME", "FY")
float niTTM  = request.financial(syminfo.tickerid, "NET_INCOME", "TTM")
float netIncome = not na(niTTM) ? niTTM : niFY

float fcfFY        = request.financial(syminfo.tickerid, "FREE_CASH_FLOW", "FY")
float fcfTTM       = request.financial(syminfo.tickerid, "FREE_CASH_FLOW", "TTM")
float fcfAnnual    = not na(fcfTTM) ? fcfTTM : fcfFY 
float fcfQuarterly = request.financial(syminfo.tickerid, "FREE_CASH_FLOW", "FQ")

float epsFY_req = request.financial(syminfo.tickerid, "EARNINGS_PER_SHARE", "FY")
float epsTTM    = request.financial(syminfo.tickerid, "EARNINGS_PER_SHARE", "TTM")
float epsFY     = not na(epsTTM) ? epsTTM : epsFY_req

float totalDebt = request.financial(syminfo.tickerid, "TOTAL_DEBT", "FQ")
float revFY     = request.financial(syminfo.tickerid, "TOTAL_REVENUE", "FY")
float revTTM    = request.financial(syminfo.tickerid, "TOTAL_REVENUE", "TTM")
float revFQ     = request.financial(syminfo.tickerid, "TOTAL_REVENUE", "FQ")

// --- Historical financial data via request.security ---
float epsFY1 = request.financial(syminfo.tickerid, "EARNINGS_PER_SHARE", "FY")[1]
float niFY1  = niFY[1]

[fcfY0_y, fcfY1_y, fcfY2_y, fcfY3_y, fcfY4_y] = request.security(syminfo.tickerid, "12M", [fcfFY, fcfFY[1], fcfFY[2], fcfFY[3], fcfFY[4]])
[revY0_y, revY1_y, revY2_y, revY3_y, revY4_y] = request.security(syminfo.tickerid, "12M", [revFY, revFY[1], revFY[2], revFY[3], revFY[4]])
[niY0_y, niY1_y]                                = request.security(syminfo.tickerid, "12M", [niFY, niFY[1]])

// --- Official Shares Outstanding Fetch & Fallbacks ---
float sharesTV      = request.financial(syminfo.tickerid, "TOTAL_SHARES_OUTSTANDING", "FQ")
float sharesOutAuto = not na(netIncome) and not na(epsFY) and epsFY != 0 ? math.abs(netIncome / epsFY) : na
float sharesOutPrev = not na(niFY1) and not na(epsFY1) and epsFY1 != 0 ? math.abs(niFY1 / epsFY1) : na
float sharesOut     = sharesInput > 0 ? sharesInput * 1000000000 : (not na(sharesTV) ? sharesTV : (not na(sharesOutAuto) ? sharesOutAuto : sharesOutPrev))
bool hasShares      = not na(sharesOut) and sharesOut > 0

// --- Comparison symbol & Trend ---
float compClose = request.security(compSymbol, timeframe.period, close)
float weeklyMA50  = request.security(syminfo.tickerid, "W", ta.sma(close, 10))
float weeklyMA200 = request.security(syminfo.tickerid, "W", ta.sma(close, 40))
bool weeklyBullish = not na(weeklyMA50) and not na(weeklyMA200) and weeklyMA50 > weeklyMA200

// ============================================================================
// SECTOR ROTATION MODULE
// ============================================================================
float techClose    = request.security("AMEX:XLK", timeframe.period, close)
float finClose     = request.security("AMEX:XLF", timeframe.period, close)
float healthClose  = request.security("AMEX:XLV", timeframe.period, close)
float energyClose  = request.security("AMEX:XLE", timeframe.period, close)
float staplesClose = request.security("AMEX:XLP", timeframe.period, close)
float utilClose    = request.security("AMEX:XLU", timeframe.period, close)

// ============================================================================
// QUARTERLY FCF ANNUALIZATION (Seasonality / Valuation Shock Filter)
// ============================================================================
float fcfQuarterlyAnnualized = not na(fcfQuarterly) ? fcfQuarterly * 4.0 : na

// Calculate test multiples to prevent massive Q4 cash-collection spikes (like ASML) from hallucinating cheap valuations
float test_fcfPS_TTM = hasShares and fcfAnnual > 0 ? fcfAnnual / sharesOut : na
float test_fcfPS_QTR = hasShares and fcfQuarterlyAnnualized > 0 ? fcfQuarterlyAnnualized / sharesOut : na

float test_pfcfTTM = not na(test_fcfPS_TTM) ? close / test_fcfPS_TTM : na
float test_pfcfQTR = not na(test_fcfPS_QTR) ? close / test_fcfPS_QTR : na

// VALUATION SHOCK: If QTRx4 causes the multiple to suddenly drop by >50% AND the resulting P/FCF is < 25x, it is mathematically a seasonal spike, NOT a cyclical boom.
bool isValuationShock = not na(test_pfcfTTM) and not na(test_pfcfQTR) and (test_pfcfQTR < test_pfcfTTM * 0.5) and (test_pfcfQTR < 25.0)

// Hardcode known ultra-lumpy/seasonal mega-caps as a backup
bool isAutoLumpy = syminfo.ticker == "ASML" or syminfo.ticker == "BA"

// Only use QTRx4 if it exceeds 1.75x TTM, is NOT lumpy, and passes the shock filter
bool fcfRunRateHigher = useQuarterlyFCF and not isLumpy and not isAutoLumpy and not isValuationShock and not na(fcfQuarterlyAnnualized) and not na(fcfAnnual) and fcfAnnual > 0 and fcfQuarterlyAnnualized > fcfAnnual * 1.75
bool fcfRunRateUsed = fcfRunRateHigher

float fcfEffective = fcfRunRateUsed ? fcfQuarterlyAnnualized : fcfAnnual
string fcfSourceLabel = fcfRunRateUsed ? "QTRÃ—4" : (not na(fcfTTM) ? "TTM" : "FY")

// ============================================================================
// FUNDAMENTAL ANALYSIS
// ============================================================================
growthCAGR(float current, float y1, float y2, float y3, float y4) =>
    float cagr = na
    string period = "N/A"
    if not na(current) and not na(y4) and y4 > 0 and current > 0
        cagr := (math.pow(current / y4, 1.0 / 4.0) - 1) * 100
        period := "4Y"
    else if not na(current) and not na(y3) and y3 > 0 and current > 0
        cagr := (math.pow(current / y3, 1.0 / 3.0) - 1) * 100
        period := "3Y"
    else if not na(current) and not na(y2) and y2 > 0 and current > 0
        cagr := (math.pow(current / y2, 1.0 / 2.0) - 1) * 100
        period := "2Y"
    else if not na(current) and not na(y1) and y1 > 0 and current > 0
        cagr := ((current / y1) - 1) * 100
        period := "1Y"
    else if not na(current)
        float baseVal = not na(y4) ? y4 : (not na(y3) ? y3 : (not na(y2) ? y2 : (not na(y1) ? y1 : na)))
        if not na(baseVal)
            if baseVal <= 0 and current > 0
                cagr := 100.0
                period := "TURNAROUND"
            else if baseVal > 0 and current <= 0
                cagr := -100.0
                period := "DETERIORATING"
            else if baseVal < 0 and current < 0
                cagr := current > baseVal ? 50.0 : -50.0
                period := current > baseVal ? "IMPROVING" : "WORSENING"
            else if baseVal == 0 and current == 0
                cagr := 0.0
                period := "FLAT"
    [cagr, period]

[revCAGR, revPeriod] = growthCAGR(revY0_y, revY1_y, revY2_y, revY3_y, revY4_y)
bool revValid = not na(revCAGR)
string revTrend = "NO DATA"
color revColor = color.gray
if revValid
    if revCAGR > 10
        revTrend := "GROWING " + revPeriod + " (+" + str.tostring(revCAGR, "#.#") + "%)"
        revColor := color.green
    else if revCAGR < -10
        revTrend := "DECLINING " + revPeriod + " (" + str.tostring(revCAGR, "#.#") + "%)"
        revColor := color.red
    else
        revTrend := "STABLE " + revPeriod + " (" + str.tostring(revCAGR, "#.#") + "%)"
        revColor := color.blue

[fcfCAGR, fcfPeriod] = growthCAGR(fcfY0_y, fcfY1_y, fcfY2_y, fcfY3_y, fcfY4_y)
bool fcfValid = not na(fcfCAGR)
string fcfTrend = "NO DATA"
color fcfColor = color.gray
if fcfValid
    if fcfCAGR > 10
        fcfTrend := "GROWING " + fcfPeriod + " (+" + str.tostring(fcfCAGR, "#.#") + "%)"
        fcfColor := color.green
    else if fcfCAGR < -10
        fcfTrend := "DECLINING " + fcfPeriod + " (" + str.tostring(fcfCAGR, "#.#") + "%)"
        fcfColor := color.red
    else
        fcfTrend := "STABLE " + fcfPeriod + " (" + str.tostring(fcfCAGR, "#.#") + "%)"
        fcfColor := color.blue

float rev1YCAGR  = not na(revY0_y) and not na(revY1_y) and revY1_y > 0 ? ((revY0_y / revY1_y) - 1) * 100 : na
float fcf1YChange = not na(fcfY0_y) and not na(fcfY1_y) and fcfY1_y > 0 ? ((fcfY0_y / fcfY1_y) - 1) * 100 : na

// --- Cyclical & Restructuring ---
bool isCyclicalBoom = false
string cyclicalLabel = ""
color cyclicalColor = color.gray
float revQtrAnnualized = not na(revFQ) ? revFQ * 4.0 : na
float revAcceleration = not na(revQtrAnnualized) and not na(revY0_y) and revY0_y > 0 ? ((revQtrAnnualized / revY0_y) - 1) * 100 : na

if revValid and revCAGR > cyclicalThreshold
    isCyclicalBoom := true
    cyclicalLabel := "ðŸ”¥ CYCLICAL BOOM (Rev CAGR " + str.tostring(revCAGR, "#.#") + "%)"
    cyclicalColor := color.yellow
else if fcfValid and fcfCAGR > cyclicalThreshold
    isCyclicalBoom := true
    cyclicalLabel := "ðŸ”¥ CYCLICAL BOOM (FCF CAGR " + str.tostring(fcfCAGR, "#.#") + "%)"
    cyclicalColor := color.yellow
else if not na(revAcceleration) and revAcceleration > 40
    isCyclicalBoom := true
    cyclicalLabel := "ðŸ”¥ ACCELERATING (Qtr +" + str.tostring(revAcceleration, "#.#") + "% vs FY)"
    cyclicalColor := color.yellow

float revDropY0Y1 = not na(revY0_y) and not na(revY1_y) and revY1_y > 0 ? ((revY0_y / revY1_y) - 1) * 100 : na
float revDropY1Y2 = not na(revY1_y) and not na(revY2_y) and revY2_y > 0 ? ((revY1_y / revY2_y) - 1) * 100 : na
bool isRestructured = not na(revDropY0Y1) and not na(revDropY1Y2) and revDropY0Y1 < -15 and revDropY1Y2 > -10

string revTrendAdj = revTrend
color revColorAdj  = revColor
if isRestructured
    revTrendAdj := "RESTRUCTURED (use 1Y)"
    revColorAdj := color.orange

// --- Profitability ---
bool isGAAPProfit = nz(netIncome) > 0
bool isCashProfitable = (not isGAAPProfit) and (not na(fcfY0_y) and fcfY0_y > 0) and (not na(epsFY) and epsFY > 0)
bool isProfitable = isGAAPProfit or isCashProfitable

string profitLabel = isGAAPProfit ? "YES (" + str.tostring(netIncome / 1000000, "#.#") + "M)" : isCashProfitable ? "CASH PROF. (" + str.tostring(fcfY0_y / 1000000, "#.#") + "M FCF)" : "NO"
color profitColor = isGAAPProfit ? color.green : isCashProfitable ? color.blue : color.red

// ============================================================================
// 9 FUNDAMENTAL WARNING SIGNS & FORECASTING
// ============================================================================
float dilutionPct = not na(sharesOut) and not na(sharesOutPrev) and sharesOutPrev > 0 ? ((sharesOut / sharesOutPrev) - 1) * 100 : na
bool warnDilution = not na(dilutionPct) and dilutionPct > 5
bool warnFCFNeg = not na(fcfY0_y) and fcfY0_y <= 0
float niGrowth  = not na(niY0_y) and not na(niY1_y) and niY1_y > 0 and niY0_y > 0 ? ((niY0_y / niY1_y) - 1) * 100 : na
float revGrowth = not na(revY0_y) and not na(revY1_y) and revY1_y > 0 ? ((revY0_y / revY1_y) - 1) * 100 : na
bool warnMarginSqueeze = not isRestructured and not na(niGrowth) and not na(revGrowth) and revGrowth > 0 and niGrowth < revGrowth and (revGrowth - niGrowth) > 5
bool warnRevDecline = not isRestructured and revValid and revCAGR < -5
bool warnEPSLoss = not na(epsFY) and epsFY < 0
bool isInvestmentPhase = revValid and fcfValid and revCAGR > 5 and fcfCAGR < -10
bool isDeteriorating   = not isRestructured and revValid and fcfValid and revCAGR < -5 and fcfCAGR < -10
bool warnFCFDeteriorate = not isRestructured and not na(fcf1YChange) and fcf1YChange < -20 and not isInvestmentPhase

bool isFCFNegative = not na(fcfEffective) and fcfEffective <= 0
float fcfPS0 = hasShares and not na(fcfEffective) and fcfEffective > 0 ? fcfEffective / sharesOut : na
float currentPFCF = not na(fcfPS0) and fcfPS0 > 0 ? close / fcfPS0 : na
bool isHighMultiple = not na(currentPFCF) and currentPFCF > 60

float pfcfWarnThreshold = isCyclicalBoom and fcfRunRateUsed ? 120.0 : 80.0
bool warnOvervalued = not na(currentPFCF) and currentPFCF > pfcfWarnThreshold
bool warnGrowthStall = not isRestructured and revValid and not na(rev1YCAGR) and revCAGR > 10 and rev1YCAGR < 5 and (revCAGR - rev1YCAGR) > 10
float debtToFCF = not na(totalDebt) and not na(fcfEffective) and fcfEffective > 0 ? totalDebt / fcfEffective : na
bool warnDebtHeavy = not na(debtToFCF) and debtToFCF > 10

int warnCount = (warnDilution ? 1 : 0) + (warnFCFNeg ? 1 : 0) + (warnMarginSqueeze ? 1 : 0) + (warnRevDecline ? 1 : 0) + (warnEPSLoss ? 1 : 0) + (warnFCFDeteriorate ? 1 : 0) + (warnOvervalued ? 1 : 0) + (warnGrowthStall ? 1 : 0) + (warnDebtHeavy ? 1 : 0)
color warnCountColor = warnCount == 0 ? color.green : (warnCount <= 2 ? color.orange : color.red)
string warnText = ""
if warnDilution
    warnText += "DILUTION(" + str.tostring(dilutionPct, "#.#") + "%) "
if warnFCFNeg
    warnText += "FCF<0 "
if warnMarginSqueeze
    warnText += "MARGINâ†“ "
if warnRevDecline
    warnText += "REVâ†“ "
if warnEPSLoss
    warnText += "EPS<0 "
if warnFCFDeteriorate
    warnText += "FCFâ†“â†“ "
if warnOvervalued
    warnText += "P/FCF>" + str.tostring(pfcfWarnThreshold, "#") + " "
if warnGrowthStall
    warnText += "STALL "
if warnDebtHeavy
    warnText += "DEBT(" + str.tostring(debtToFCF, "#.#") + "Y) "
if isRestructured
    warnText += "ðŸ“‹RESTRUCTURED "
if isCyclicalBoom
    warnText += "ðŸ”¥CYCL "
if warnCount == 0 and not isRestructured
    warnText := "ALL CLEAR âœ“"
else if warnCount == 0 and isRestructured
    warnText := "ðŸ“‹RESTRUCTURED (data adj.)"

decayGrowth(float rawCAGR) =>
    float adj = rawCAGR
    if rawCAGR > 50
        adj := 35.0 + (rawCAGR - 50.0) * 0.25
    else if rawCAGR > 20
        adj := 20.0 + (rawCAGR - 20.0) * 0.5
    adj

float smartFCFGrowth = 0.0
string fcfAdjLabel   = ""
if isRestructured
    smartFCFGrowth := 0.0
    fcfAdjLabel := "RESTRUCTURED"
else if isCyclicalBoom and fcfValid and fcfCAGR > cyclicalThreshold
    smartFCFGrowth := decayGrowth(fcfCAGR) * 0.7
    fcfAdjLabel := "CYCL DECAY"
else if isInvestmentPhase
    smartFCFGrowth := math.max(0, (fcfCAGR + revCAGR) / 2.0)
    fcfAdjLabel := "INVEST ADJ"
else if fcfValid
    if fcfCAGR > 20
        smartFCFGrowth := decayGrowth(fcfCAGR)
        fcfAdjLabel := "DECAY ADJ"
    else
        smartFCFGrowth := fcfCAGR
else
    smartFCFGrowth := 0.0

float fcfGrowthRate = math.max(-0.4, math.min(smartFCFGrowth / 100.0, 0.4))
bool forecastValid = not na(currentPFCF) and not na(fcfPS0) and fcfPS0 > 0 and not isFCFNegative
float fcfPerShareFwd = forecastValid ? fcfPS0 * (1 + fcfGrowthRate) : na
float forecastMultiple = currentPFCF
if isCyclicalBoom and forecastValid and currentPFCF > 50
    forecastMultiple := (currentPFCF + 35.0) / 2.0

float priceBear = forecastValid ? fcfPerShareFwd * forecastMultiple * 0.70 : na
float priceFair = forecastValid ? fcfPerShareFwd * forecastMultiple * 1.00 : na
float priceBull = forecastValid ? fcfPerShareFwd * forecastMultiple * 1.30 : na

float upsideBear = forecastValid and close > 0 ? ((priceBear / close) - 1) * 100 : na
float upsideFair = forecastValid and close > 0 ? ((priceFair / close) - 1) * 100 : na
float upsideBull = forecastValid and close > 0 ? ((priceBull / close) - 1) * 100 : na

int fundScore = (isProfitable ? 1 : 0) + (not na(fcfEffective) and fcfEffective > 0 ? 1 : 0) + (fcfValid and fcfCAGR > 5 ? 1 : 0) + (revValid and revCAGR > 5 ? 1 : 0) + (not na(epsFY) and epsFY > 0 ? 1 : 0)
string fundGrade = fundScore >= 5 ? "A+" : fundScore >= 4 ? "A" : fundScore >= 3 ? "B" : fundScore >= 2 ? "C" : fundScore >= 1 ? "D" : "F"
color fundGradeColor = fundScore >= 4 ? color.green : fundScore >= 3 ? color.blue : fundScore >= 2 ? color.orange : color.red

// ============================================================================
// SECTOR ROTATION & TECHNICAL CALCULATIONS
// ============================================================================
scorePhases(float techP, float finP, float healthP, float energyP, float staplesP, float utilP) =>
    float early = 0.0
    float mid = 0.0
    float late = 0.0
    float defense = 0.0
    if finP > techP
        early += 1
    if finP > energyP
        early += 1
    if finP > staplesP
        early += 1
    if techP > finP
        mid += 1
    if techP > energyP
        mid += 1
    if techP > staplesP
        mid += 1
    if techP > utilP
        mid += 1
    if energyP > techP
        late += 1
    if energyP > finP
        late += 1
    if energyP > staplesP
        late += 1
    if staplesP > techP
        defense += 1
    if utilP > techP
        defense += 1
    if healthP > techP
        defense += 1
    if staplesP > energyP
        defense += 1
    [early, mid, late, defense]

isSectorInPhase(string sector, string phase) =>
    bool result = false
    if phase == "EARLY RECOVERY"
        result := sector == "Finance" or sector == "Financial" or sector == "Real Estate" or sector == "Consumer Cyclical" or sector == "Consumer Durables" or sector == "Retail Trade" or sector == "Transportation"
    else if phase == "MID EXPANSION"
        result := sector == "Technology" or sector == "Technology Services" or sector == "Electronic Technology" or sector == "Industrials" or sector == "Industrial Services" or sector == "Producer Manufacturing" or sector == "Communication Services" or sector == "Communications" or sector == "Transportation"
    else if phase == "LATE EXPANSION"
        result := sector == "Energy" or sector == "Energy Minerals" or sector == "Basic Materials" or sector == "Non-Energy Minerals" or sector == "Process Industries" or sector == "Industrials" or sector == "Industrial Services" or sector == "Producer Manufacturing" or sector == "Transportation"
    else if phase == "DEFENSIVE"
        result := sector == "Healthcare" or sector == "Health Technology" or sector == "Health Services" or sector == "Consumer Defensive" or sector == "Consumer Non-Durables" or sector == "Consumer Services" or sector == "Utilities" or sector == "Distribution Services"
    result

calcPerf(float currentVal, float pastVal) =>
    not na(currentVal) and not na(pastVal) and pastVal > 0 ? (currentVal / pastVal - 1) * 100 : na

float techPerfL    = calcPerf(techClose, techClose[rotationLookback])
float finPerfL     = calcPerf(finClose, finClose[rotationLookback])
float healthPerfL  = calcPerf(healthClose, healthClose[rotationLookback])
float energyPerfL  = calcPerf(energyClose, energyClose[rotationLookback])
float staplesPerfL = calcPerf(staplesClose, staplesClose[rotationLookback])
float utilPerfL    = calcPerf(utilClose, utilClose[rotationLookback])
bool rotDataValid = not na(techPerfL) and not na(finPerfL) and not na(healthPerfL) and not na(energyPerfL) and not na(staplesPerfL) and not na(utilPerfL)

int shortLookback = 20
float techPerfS    = calcPerf(techClose, techClose[shortLookback])
float finPerfS     = calcPerf(finClose, finClose[shortLookback])
float healthPerfS  = calcPerf(healthClose, healthClose[shortLookback])
float energyPerfS  = calcPerf(energyClose, energyClose[shortLookback])
float staplesPerfS = calcPerf(staplesClose, staplesClose[shortLookback])
float utilPerfS    = calcPerf(utilClose, utilClose[shortLookback])
bool rotShortValid = not na(techPerfS) and not na(finPerfS) and not na(healthPerfS) and not na(energyPerfS) and not na(staplesPerfS) and not na(utilPerfS)

[earlyScoreL, midScoreL, lateScoreL, defenseScoreL] = scorePhases(techPerfL, finPerfL, healthPerfL, energyPerfL, staplesPerfL, utilPerfL)
[earlyScoreS, midScoreS, lateScoreS, defenseScoreS] = scorePhases(techPerfS, finPerfS, healthPerfS, energyPerfS, staplesPerfS, utilPerfS)

determinePhase(float earlyS, float midS, float lateS, float defS) =>
    float maxS = math.max(math.max(earlyS, midS), math.max(lateS, defS))
    string phase = "NO DATA"
    if maxS == midS and midS > 0
        phase := "MID EXPANSION"
    else if maxS == earlyS and earlyS > 0
        phase := "EARLY RECOVERY"
    else if maxS == lateS and lateS > 0
        phase := "LATE EXPANSION"
    else if maxS == defS and defS > 0
        phase := "DEFENSIVE"
    phase

string longPhase  = rotDataValid  ? determinePhase(earlyScoreL, midScoreL, lateScoreL, defenseScoreL) : "NO DATA"
string shortPhase = rotShortValid ? determinePhase(earlyScoreS, midScoreS, lateScoreS, defenseScoreS) : "NO DATA"

bool isTransitioning = rotDataValid and rotShortValid and longPhase != shortPhase and shortPhase != "NO DATA"
string activePhase = rotShortValid ? shortPhase : longPhase

string cyclePhase = "NO DATA"
color cycleColor = color.gray
string nextPhase = "NO DATA"
color nextColor = color.gray
string transitionLabel = ""

if rotDataValid
    if activePhase == "MID EXPANSION"
        cyclePhase := isTransitioning ? "Â» MID EXPANSION" : "MID EXPANSION"
        cycleColor := color.blue
        nextPhase := "LATE EXPANSION"
        nextColor := color.orange
    else if activePhase == "EARLY RECOVERY"
        cyclePhase := isTransitioning ? "Â» EARLY RECOVERY" : "EARLY RECOVERY"
        cycleColor := color.green
        nextPhase := "MID EXPANSION"
        nextColor := color.blue
    else if activePhase == "LATE EXPANSION"
        cyclePhase := isTransitioning ? "Â» LATE EXPANSION" : "LATE EXPANSION"
        cycleColor := color.orange
        nextPhase := "DEFENSIVE"
        nextColor := color.red
    else if activePhase == "DEFENSIVE"
        cyclePhase := isTransitioning ? "Â» DEFENSIVE" : "DEFENSIVE"
        cycleColor := color.red
        nextPhase := "EARLY RECOVERY"
        nextColor := color.green
    if isTransitioning
        transitionLabel := " (was " + longPhase + ")"

string stockSector = syminfo.sector
bool isFavoredSector = isSectorInPhase(stockSector, activePhase)
bool isNextFavored   = isSectorInPhase(stockSector, nextPhase)
string sectorFitLabel = "NO DATA"
color sectorFitColor = color.gray
if rotDataValid
    if isFavoredSector and not isTransitioning
        sectorFitLabel := "FAVORED"
        sectorFitColor := color.green
    else if isFavoredSector and isTransitioning
        sectorFitLabel := "ROTATING IN"
        sectorFitColor := color.green
    else if isNextFavored
        sectorFitLabel := "SMART MONEY"
        sectorFitColor := color.blue
    else if isTransitioning and not isFavoredSector and not isNextFavored
        sectorFitLabel := "ROTATING OUT"
        sectorFitColor := color.orange
    else
        sectorFitLabel := "OUT OF FAVOR"
        sectorFitColor := color.red

float ma50        = ta.sma(close, smaFast)
float ma200       = ta.sma(close, smaSlow)
float avgVol      = ta.sma(volume, 50)
float highestHigh = ta.highest(high, baseLookback)
float lowestLow   = ta.lowest(low, baseLookback)
float atrVal      = ta.atr(atrLen)
float rsiVal      = ta.rsi(close, rsiLen)

float trueRange  = ta.tr(true)
float dmPlus     = math.max(high - high[1], 0)
float dmMinus    = math.max(low[1] - low, 0)
float dmPClean   = dmPlus > dmMinus ? dmPlus : 0.0
float dmMClean   = dmMinus > dmPlus ? dmMinus : 0.0
float smTR       = ta.rma(trueRange, adxLen)
float smDMPlus   = ta.rma(dmPClean, adxLen)
float smDMMinus  = ta.rma(dmMClean, adxLen)
float diPlus     = smTR > 0 ? (smDMPlus / smTR) * 100 : 0.0
float diMinus    = smTR > 0 ? (smDMMinus / smTR) * 100 : 0.0
float diSum      = diPlus + diMinus
float dx         = diSum > 0 ? math.abs(diPlus - diMinus) / diSum * 100 : 0.0
float adxVal     = ta.rma(dx, adxLen)
bool isTrending  = adxVal > adxThreshold

float prevClose     = close[20]
float prevCompClose = compClose[20]
bool rsDataValid    = not na(compClose) and not na(prevCompClose) and not na(prevClose) and prevClose > 0 and prevCompClose > 0
float symbolPerf    = rsDataValid ? (close - prevClose) / prevClose : 0.0
float compPerf      = rsDataValid ? (compClose - prevCompClose) / prevCompClose : 0.0
bool isRSStrong     = rsDataValid and symbolPerf > compPerf

float prevC          = nz(close[1], close)
float logReturn      = prevC > 0 and close > 0 ? math.log(close / prevC) : 0.0
float logStdDev      = ta.stdev(logReturn, probLookback)
float expectedMovePct = logStdDev * math.sqrt(5) * 100
float expectedMove    = close * logStdDev * math.sqrt(5)

float distToMA50 = close - ma50
float warnProb   = na(distToMA50) ? na : (distToMA50 > 0 ? math.min(100, (expectedMove / distToMA50) * 50) : 100.0)
float distToHigh = highestHigh - close
float entryProb  = na(distToHigh) ? na : (distToHigh > 0 ? math.min(100, (expectedMove / distToHigh) * 50) : 0.0)

bool ma50Rising  = ma50 > ma50[5]
float maxVol5    = ta.highest(volume, 5)
bool isHighVol   = maxVol5 > avgVol * volThreshold
string volStatus = "STABLE"
color volColor   = color.blue
if isHighVol
    if close > close[1] and close > ma50
        volStatus := "ACCUMULATION"
        volColor := color.green
    else
        volStatus := "DISTRIBUTION"
        volColor := color.red

float distToMA50Pct  = ma50 > 0  ? ((close - ma50) / ma50) * 100   : na
float distToMA200Pct = ma200 > 0 ? ((close - ma200) / ma200) * 100 : na
color ma50Color = ma50 > ma200 ? color.blue : color.orange

float stopATR   = close - (atrVal * 2)
float stopBase  = lowestLow
float stopLevel = math.max(stopATR, stopBase)
float riskPerShare   = close - stopLevel
float rewardPerShare = highestHigh - close
float rrRatio        = riskPerShare > 0 ? rewardPerShare / riskPerShare : na

bool rawEntry   = ta.crossover(close, highestHigh[1]) and volume > avgVol * 1.2 and close > ma50 and close > ma200
bool rawWarning = ta.crossunder(close, ma50) and volume > avgVol * 1.1
bool filteredEntry   = rawEntry and isProfitable and isTrending and rsiVal < rsiOB and weeklyBullish
bool filteredWarning = rawWarning

var int lastEntryBar   = na
var int lastWarningBar = na
bool entryCooldownOk   = na(lastEntryBar)   or (bar_index - lastEntryBar)   >= cooldownBars
bool warningCooldownOk = na(lastWarningBar) or (bar_index - lastWarningBar) >= cooldownBars
bool entrySignal   = filteredEntry   and entryCooldownOk
bool warningSignal = filteredWarning and warningCooldownOk
if entrySignal
    lastEntryBar := bar_index
if warningSignal
    lastWarningBar := bar_index

// ============================================================================
// VISUALIZATION
// ============================================================================
bool isBase = (highestHigh - lowestLow) < lowestLow * 0.15
bgcolor(isBase ? color.new(color.gray, 90) : na)

plot(ma50, color=ma50Rising ? ma50Color : color.red, linewidth=2, title="50 SMA")
plot(ma200, color=color.white, linewidth=3, title="200 SMA")
plot(stopLevel, color=color.new(color.red, 60), linewidth=1, style=plot.style_cross, title="Suggested Stop")

// plot(showForecast and forecastValid ? priceBull : na, color=color.new(color.green, 40), linewidth=1, style=plot.style_line, title="Bull Target (1Y)")
// plot(showForecast and forecastValid ? priceFair : na, color=color.new(color.yellow, 40), linewidth=2, style=plot.style_line, title="Fair Value (1Y)")
// plot(showForecast and forecastValid ? priceBear : na, color=color.new(color.red, 40),   linewidth=1, style=plot.style_line, title="Bear Target (1Y)")

plotshape(entrySignal,   title="ENTRY",   style=shape.labelup,   location=location.belowbar, color=color.green, text="ENTRY",   textcolor=color.white, size=size.small)
plotshape(warningSignal, title="WARNING", style=shape.labeldown, location=location.abovebar, color=color.red,   text="WARNING", textcolor=color.white, size=size.small)

// ============================================================================
// DASHBOARD
// ============================================================================
var table masterTable = table.new(position.top_right, 2, 32, bgcolor=color.new(color.black, 70), border_width=1, border_color=color.gray)

if barstate.islast
    color wColor  = warnProb > 70 ? color.red : (warnProb > 40 ? color.orange : color.green)
    color eColor  = entryProb > 70 ? color.green : (entryProb > 40 ? color.orange : color.red)
    color rsColor = isRSStrong ? color.green : color.red

    int row = 0

    table.cell(masterTable, 0, row, "âš  WARNINGS", text_color=color.white)
    table.cell(masterTable, 1, row, str.tostring(warnCount) + "/9: " + warnText, bgcolor=warnCountColor, text_color=color.white, text_size=size.small)
    row += 1

    table.cell(masterTable, 0, row, "FUND. GRADE", text_color=color.white)
    table.cell(masterTable, 1, row, fundGrade + " (" + str.tostring(fundScore) + "/5)", bgcolor=fundGradeColor, text_color=color.white)
    row += 1

    table.cell(masterTable, 0, row, "GAAP PROFIT", text_color=color.white)
    table.cell(masterTable, 1, row, profitLabel, bgcolor=profitColor, text_color=color.white)
    row += 1

    color epsColor = not na(epsFY) and epsFY > 0 ? color.green : color.red
    table.cell(masterTable, 0, row, "EPS (TTM)", text_color=color.white)
    table.cell(masterTable, 1, row, not na(epsFY) ? str.tostring(epsFY, "#.##") : "N/A", bgcolor=not na(epsFY) ? epsColor : color.gray, text_color=color.white)
    row += 1

    table.cell(masterTable, 0, row, "REVENUE", text_color=color.white)
    table.cell(masterTable, 1, row, revTrendAdj, bgcolor=revColorAdj, text_color=color.white)
    row += 1

    table.cell(masterTable, 0, row, "FCF TREND", text_color=color.white)
    table.cell(masterTable, 1, row, fcfTrend, bgcolor=fcfColor, text_color=color.white)
    row += 1

    if isRestructured
        table.cell(masterTable, 0, row, "ðŸ“‹ PHASE", text_color=color.white)
        table.cell(masterTable, 1, row, "RESTRUCTURED / SPINOFF", bgcolor=color.orange, text_color=color.white)
        row += 1
    else if isCyclicalBoom
        table.cell(masterTable, 0, row, "ðŸ”¥ PHASE", text_color=color.white)
        table.cell(masterTable, 1, row, cyclicalLabel, bgcolor=cyclicalColor, text_color=color.white, text_size=size.small)
        row += 1
    else if isInvestmentPhase
        table.cell(masterTable, 0, row, "âš  PHASE", text_color=color.white)
        table.cell(masterTable, 1, row, "INVESTING (Revâ†‘ FCFâ†“)", bgcolor=color.orange, text_color=color.white)
        row += 1
    else if isDeteriorating
        table.cell(masterTable, 0, row, "âš  PHASE", text_color=color.white)
        table.cell(masterTable, 1, row, "DETERIORATING", bgcolor=color.red, text_color=color.white)
        row += 1

    string pfcfLabel = "N/A"
    color pfcfNowColor = color.gray
    if isFCFNegative
        pfcfLabel := "NEG FCF âœ—"
        pfcfNowColor := color.red
    else if not na(currentPFCF)
        pfcfLabel := str.tostring(currentPFCF, "#.#") + "x"
        if fcfRunRateUsed
            pfcfLabel += " [" + fcfSourceLabel + "]"
        if isHighMultiple
            pfcfLabel += " âš  HIGH"
        pfcfNowColor := currentPFCF < 30 ? color.green : (currentPFCF < 60 ? color.blue : color.orange)

    table.cell(masterTable, 0, row, "P/FCF (NOW)", text_color=color.white)
    table.cell(masterTable, 1, row, pfcfLabel, bgcolor=pfcfNowColor, text_color=color.white)
    row += 1

    string forecastBasisText = "N/A"
    color basisColor = color.gray
    if not forecastValid and isFCFNegative
        forecastBasisText := "NO FORECAST (FCF < 0)"
        basisColor := color.red
    else if forecastValid
        string growthLabel = (fcfGrowthRate >= 0 ? "+" : "") + str.tostring(fcfGrowthRate * 100, "#.#") + "%"
        if fcfAdjLabel != ""
            growthLabel += " (" + fcfAdjLabel + ")"
        string multLabel = isCyclicalBoom and currentPFCF > 50 ? "NORM " + str.tostring(forecastMultiple, "#.#") + "x" : "Â±30% MULT"
        forecastBasisText := fcfSourceLabel + ": " + growthLabel + " | " + multLabel
        basisColor := fcfAdjLabel != "" ? color.orange : color.gray

    table.cell(masterTable, 0, row, "FORECAST BASIS", text_color=color.white)
    table.cell(masterTable, 1, row, forecastBasisText, bgcolor=basisColor, text_color=color.white, text_size=size.small)
    row += 1

    color bearColor = not na(upsideBear) ? (upsideBear > 0 ? color.green : color.red) : color.gray
    color fairColor = not na(upsideFair) ? (upsideFair > 0 ? color.green : color.red) : color.gray
    color bullColor = not na(upsideBull) ? (upsideBull > 0 ? color.green : color.red) : color.gray

    table.cell(masterTable, 0, row, "1Y BEAR", text_color=color.white)
    table.cell(masterTable, 1, row, forecastValid ? str.tostring(priceBear, "#.##") + " (" + str.tostring(upsideBear, "#.#") + "%)" : "N/A", bgcolor=bearColor, text_color=color.white)
    row += 1

    table.cell(masterTable, 0, row, "1Y FAIR", text_color=color.white)
    table.cell(masterTable, 1, row, forecastValid ? str.tostring(priceFair, "#.##") + " (" + str.tostring(upsideFair, "#.#") + "%)" : "N/A", bgcolor=fairColor, text_color=color.white)
    row += 1

    table.cell(masterTable, 0, row, "1Y BULL", text_color=color.white)
    table.cell(masterTable, 1, row, forecastValid ? str.tostring(priceBull, "#.##") + " (" + str.tostring(upsideBull, "#.#") + "%)" : "N/A", bgcolor=bullColor, text_color=color.white)
    row += 1

    table.cell(masterTable, 0, row, "TREND", text_color=color.white)
    table.cell(masterTable, 1, row, ma50Rising ? "BULLISH" : "BEARISH", bgcolor=ma50Rising ? color.green : color.red, text_color=color.white)
    row += 1

    table.cell(masterTable, 0, row, "WEEKLY TREND", text_color=color.white)
    table.cell(masterTable, 1, row, weeklyBullish ? "BULLISH" : "BEARISH", bgcolor=weeklyBullish ? color.green : color.red, text_color=color.white)
    row += 1

    color adxColor = isTrending ? color.green : color.gray
    table.cell(masterTable, 0, row, "ADX (TREND)", text_color=color.white)
    table.cell(masterTable, 1, row, str.tostring(adxVal, "#.#") + (isTrending ? " TRENDING" : " CHOPPY"), bgcolor=adxColor, text_color=color.white)
    row += 1

    color rsiColor  = rsiVal > rsiOB ? color.red : (rsiVal < 30 ? color.green : color.blue)
    string rsiLabel = rsiVal > rsiOB ? " OVERBOUGHT" : (rsiVal < 30 ? " OVERSOLD" : "")
    table.cell(masterTable, 0, row, "RSI", text_color=color.white)
    table.cell(masterTable, 1, row, str.tostring(rsiVal, "#.#") + rsiLabel, bgcolor=rsiColor, text_color=color.white)
    row += 1

    table.cell(masterTable, 0, row, "VOLUME", text_color=color.white)
    table.cell(masterTable, 1, row, volStatus, bgcolor=volColor, text_color=color.white)
    row += 1

    table.cell(masterTable, 0, row, "RS vs " + compSymbol, text_color=color.white)
    table.cell(masterTable, 1, row, rsDataValid ? (isRSStrong ? "STRONGER" : "WEAKER") : "NO DATA", bgcolor=rsDataValid ? rsColor : color.gray, text_color=color.white)
    row += 1

    table.cell(masterTable, 0, row, "CYCLE PHASE", text_color=color.white)
    string cycleDisplay = isTransitioning ? cyclePhase + transitionLabel : cyclePhase
    table.cell(masterTable, 1, row, cycleDisplay, bgcolor=cycleColor, text_color=color.white, text_size=size.small)
    row += 1

    string sectorDisplay = stockSector != "" ? stockSector : "UNKNOWN"
    table.cell(masterTable, 0, row, "SECTOR FIT", text_color=color.white)
    table.cell(masterTable, 1, row, sectorFitLabel + " (" + sectorDisplay + ")", bgcolor=sectorFitColor, text_color=color.white, text_size=size.small)
    row += 1

    table.cell(masterTable, 0, row, "NEXT PHASE", text_color=color.white)
    table.cell(masterTable, 1, row, nextPhase, bgcolor=nextColor, text_color=color.white)
    row += 1

    table.cell(masterTable, 0, row, "PROB. WARNING (5d)", text_color=color.white)
    table.cell(masterTable, 1, row, not na(warnProb) ? str.tostring(warnProb, "#.##") + "%" : "N/A", bgcolor=wColor, text_color=color.white)
    row += 1

    table.cell(masterTable, 0, row, "PROB. ENTRY (5d)", text_color=color.white)
    table.cell(masterTable, 1, row, not na(entryProb) ? str.tostring(entryProb, "#.##") + "%" : "N/A", bgcolor=eColor, text_color=color.white)
    row += 1

    color d50Color = not na(distToMA50Pct) ? (distToMA50Pct > 0 ? color.green : color.red) : color.gray
    table.cell(masterTable, 0, row, "DIST. TO MA50", text_color=color.white)
    table.cell(masterTable, 1, row, not na(distToMA50Pct) ? str.tostring(distToMA50Pct, "#.##") + "%" : "N/A", bgcolor=d50Color, text_color=color.white)
    row += 1

    color d200Color = not na(distToMA200Pct) ? (distToMA200Pct > 0 ? color.green : color.red) : color.gray
    table.cell(masterTable, 0, row, "DIST. TO MA200", text_color=color.white)
    table.cell(masterTable, 1, row, not na(distToMA200Pct) ? str.tostring(distToMA200Pct, "#.##") + "%" : "N/A", bgcolor=d200Color, text_color=color.white)
    row += 1

    table.cell(masterTable, 0, row, "STOP / R:R", text_color=color.white)
    string rrText = not na(rrRatio) and rrRatio > 0 ? str.tostring(stopLevel, "#.##") + " | 1:" + str.tostring(rrRatio, "#.#") : str.tostring(stopLevel, "#.##") + " | N/A"
    color rrColor = not na(rrRatio) and rrRatio >= 2 ? color.green : (not na(rrRatio) and rrRatio >= 1 ? color.orange : color.red)
    table.cell(masterTable, 1, row, rrText, bgcolor=rrColor, text_color=color.white)
    row += 1

    if fcfRunRateUsed
        float fcfFYDisplay = not na(fcfAnnual) ? fcfAnnual / 1000000 : na
        float fcfQDisplay  = not na(fcfQuarterlyAnnualized) ? fcfQuarterlyAnnualized / 1000000 : na
        string fcfSrcText = "BASE: " + (not na(fcfFYDisplay) ? str.tostring(fcfFYDisplay, "#.#") + "M" : "N/A") + " â†’ QTRÃ—4: " + (not na(fcfQDisplay) ? str.tostring(fcfQDisplay, "#.#") + "M" : "N/A")
        table.cell(masterTable, 0, row, "ðŸ“Š FCF SOURCE", text_color=color.white)
        table.cell(masterTable, 1, row, fcfSrcText, bgcolor=color.new(color.yellow, 40), text_color=color.white, text_size=size.small)
        row += 1

    if isCyclicalBoom and forecastValid and currentPFCF > 50
        string normText = "P/FCF: " + str.tostring(currentPFCF, "#.#") + "x â†’ NORM " + str.tostring(forecastMultiple, "#.#") + "x"
        table.cell(masterTable, 0, row, "ðŸ“Š MULT. ADJ", text_color=color.white)
        table.cell(masterTable, 1, row, normText, bgcolor=color.new(color.yellow, 40), text_color=color.white, text_size=size.small)
        row += 1