//@version=6
indicator("Palantir Strategy: Ultimate Master Guard V15", overlay=true, max_labels_count=500)

// ============================================================================
// INPUTS
// ============================================================================
int smaFast          = input.int(50,    "Momentum Line (50)",             minval=1)
int smaSlow          = input.int(200,   "Trend Line (200)",              minval=1)
float volThreshold   = input.float(1.5, "Volume Trigger (x Average)",    minval=1.1)
int baseLookback     = input.int(50,    "Base Lookback Period (Bars)",    minval=20)
int probLookback     = input.int(20,    "Volatility Forecast Period",    minval=5)
string compSymbol    = input.symbol("URTH", "Comparison Symbol (RS)")
int cooldownBars     = input.int(10,    "Signal Cooldown (Bars)",        minval=1)
int adxLen           = input.int(14,    "ADX Length",                    minval=5)
float adxThreshold   = input.float(20,  "ADX Trend Threshold",          minval=10)
int rsiLen           = input.int(14,    "RSI Length",                    minval=5)
float rsiOB          = input.float(75,  "RSI Overbought Level",         minval=60, maxval=95)
int atrLen           = input.int(14,    "ATR Length",                    minval=5)
bool showForecast    = input.bool(true, "Show Price Forecast Lines")
float sharesInput    = input.float(0, "Shares Outstanding (B) â€” 0=auto", minval=0, tooltip="Enter shares in billions. Set 0 to auto-detect.")
int rotationLookback = input.int(60, "Sector Rotation Lookback (Days)", minval=20, maxval=120)
bool useQuarterlyFCF = input.bool(true, "Use Quarterly FCF Annualization (Cyclicals)", tooltip="When the most recent quarter's annualized FCF significantly exceeds trailing annual FCF, use the quarterly run-rate instead. Better for cyclical stocks in upswings.")
float cyclicalThreshold = input.float(50, "Cyclical Boom Threshold (Rev CAGR %)", minval=30, maxval=100, tooltip="Revenue or FCF CAGR above this level flags the stock as in a cyclical boom phase.")
bool isLumpy         = input.bool(false, "Lumpy Cash Flow Override", tooltip="Check this for companies with massive but infrequent product deliveries to disable QTRx4.")

// ============================================================================
// SECTOR DETECTION (Dynamic Valuation Toggle)
// ============================================================================
string stockSector = syminfo.sector
bool isBank    = stockSector == "Finance" or stockSector == "Financial" or stockSector == "Financials"
bool isUtility = stockSector == "Utilities" or stockSector == "Utility"

// ============================================================================
// DATA REQUESTS (Global Scope)
// ============================================================================

// --- Core financial data ---
float niFY   = request.financial(syminfo.tickerid, "NET_INCOME", "FY")
float niTTM  = request.financial(syminfo.tickerid, "NET_INCOME", "TTM")
float netIncome = not na(niTTM) ? niTTM : niFY

float fcfFY        = request.financial(syminfo.tickerid, "FREE_CASH_FLOW", "FY")
float fcfTTM       = request.financial(syminfo.tickerid, "FREE_CASH_FLOW", "TTM")
float fcfAnnual    = not na(fcfTTM) ? fcfTTM : fcfFY 
float fcfQuarterly = request.financial(syminfo.tickerid, "FREE_CASH_FLOW", "FQ")

float epsFY_req = request.financial(syminfo.tickerid, "EARNINGS_PER_SHARE", "FY")
float epsTTM    = request.financial(syminfo.tickerid, "EARNINGS_PER_SHARE", "TTM")
float epsFY     = not na(epsTTM) ? epsTTM : epsFY_req

float totalDebt = request.financial(syminfo.tickerid, "TOTAL_DEBT", "FQ")
float revFY     = request.financial(syminfo.tickerid, "TOTAL_REVENUE", "FY")
float revTTM    = request.financial(syminfo.tickerid, "TOTAL_REVENUE", "TTM")
float revFQ     = request.financial(syminfo.tickerid, "TOTAL_REVENUE", "FQ")

// --- BANK UPGRADE: Total Equity for Book Value ---
float equityFQ  = request.financial(syminfo.tickerid, "TOTAL_EQUITY", "FQ")
float equityFY  = request.financial(syminfo.tickerid, "TOTAL_EQUITY", "FY")
float curEquity = not na(equityFQ) ? equityFQ : equityFY

// --- Historical financial data ---
float epsFY1 = request.financial(syminfo.tickerid, "EARNINGS_PER_SHARE", "FY")[1]
float niFY1  = niFY[1]

[fcfY0_y, fcfY1_y, fcfY2_y, fcfY3_y, fcfY4_y] = request.security(syminfo.tickerid, "12M", [fcfFY, fcfFY[1], fcfFY[2], fcfFY[3], fcfFY[4]])
[revY0_y, revY1_y, revY2_y, revY3_y, revY4_y] = request.security(syminfo.tickerid, "12M", [revFY, revFY[1], revFY[2], revFY[3], revFY[4]])
[niY0_y, niY1_y]                                = request.security(syminfo.tickerid, "12M", [niFY, niFY[1]])
[eqY0_y, eqY1_y, eqY2_y, eqY3_y, eqY4_y]      = request.security(syminfo.tickerid, "12M", [equityFY, equityFY[1], equityFY[2], equityFY[3], equityFY[4]])
[epsY0_y, epsY1_y, epsY2_y, epsY3_y, epsY4_y] = request.security(syminfo.tickerid, "12M", [epsFY, epsFY_req[1], epsFY_req[2], epsFY_req[3], epsFY_req[4]])

// --- Official Shares Outstanding Fetch & Fallbacks ---
float sharesTV      = request.financial(syminfo.tickerid, "TOTAL_SHARES_OUTSTANDING", "FQ")
float sharesOutAuto = not na(netIncome) and not na(epsFY) and epsFY != 0 ? math.abs(netIncome / epsFY) : na
float sharesOutPrev = not na(niFY1) and not na(epsFY1) and epsFY1 != 0 ? math.abs(niFY1 / epsFY1) : na
float sharesOut     = sharesInput > 0 ? sharesInput * 1000000000 : (not na(sharesTV) ? sharesTV : (not na(sharesOutAuto) ? sharesOutAuto : sharesOutPrev))
bool hasShares      = not na(sharesOut) and sharesOut > 0

// --- Comparison symbol & Trend ---
float compClose   = request.security(compSymbol, timeframe.period, close)
float weeklyMA50  = request.security(syminfo.tickerid, "W", ta.sma(close, 10))
float weeklyMA200 = request.security(syminfo.tickerid, "W", ta.sma(close, 40))
bool weeklyBullish = not na(weeklyMA50) and not na(weeklyMA200) and weeklyMA50 > weeklyMA200

// ============================================================================
// SECTOR ROTATION MODULE
// ============================================================================
float techClose    = request.security("AMEX:XLK", timeframe.period, close)
float finClose     = request.security("AMEX:XLF", timeframe.period, close)
float healthClose  = request.security("AMEX:XLV", timeframe.period, close)
float energyClose  = request.security("AMEX:XLE", timeframe.period, close)
float staplesClose = request.security("AMEX:XLP", timeframe.period, close)
float utilClose    = request.security("AMEX:XLU", timeframe.period, close)

// ============================================================================
// VALUATION MODEL SELECTION
// ============================================================================
// Logic: 
// 1. Banks -> P/B Model (Equity)
// 2. Utilities -> P/E Model (EPS) - Because FCF is often negative due to CapEx
// 3. Unprofitable Growth -> P/S Model (Revenue) - Net Income & FCF < 0
// 4. Standard -> P/FCF Model

float fcfQuarterlyAnnualized = not na(fcfQuarterly) ? fcfQuarterly * 4.0 : na
bool isValuationShock = false // Simplified for V15 to rely on model switching
bool isAutoLumpy = syminfo.ticker == "ASML" or syminfo.ticker == "BA"

bool fcfRunRateHigher = useQuarterlyFCF and not isLumpy and not isAutoLumpy and not na(fcfQuarterlyAnnualized) and not na(fcfAnnual) and fcfAnnual > 0 and fcfQuarterlyAnnualized > fcfAnnual * 1.75
bool fcfRunRateUsed = fcfRunRateHigher
float fcfEffective = fcfRunRateUsed ? fcfQuarterlyAnnualized : fcfAnnual

// Detect Unprofitable Growth
bool isNoProfit = (na(netIncome) or netIncome <= 0) and (na(fcfEffective) or fcfEffective <= 0)
bool isGrowthSpec = (not isBank and not isUtility) and isNoProfit

string valuationModel = "FCF"
if isBank
    valuationModel := "BOOK"
else if isUtility
    valuationModel := "EARNINGS"
else if isGrowthSpec
    valuationModel := "SALES"
else
    valuationModel := "FCF"

// ============================================================================
// FUNDAMENTAL ANALYSIS (CAGR & Trends)
// ============================================================================
growthCAGR(float current, float y1, float y2, float y3, float y4) =>
    float cagr = na
    string period = "N/A"
    if not na(current) and not na(y4) and y4 > 0 and current > 0
        cagr := (math.pow(current / y4, 1.0 / 4.0) - 1) * 100
        period := "4Y"
    else if not na(current) and not na(y3) and y3 > 0 and current > 0
        cagr := (math.pow(current / y3, 1.0 / 3.0) - 1) * 100
        period := "3Y"
    else if not na(current) and not na(y2) and y2 > 0 and current > 0
        cagr := (math.pow(current / y2, 1.0 / 2.0) - 1) * 100
        period := "2Y"
    else if not na(current) and not na(y1) and y1 > 0 and current > 0
        cagr := ((current / y1) - 1) * 100
        period := "1Y"
    else if not na(current)
        float baseVal = not na(y4) ? y4 : (not na(y3) ? y3 : (not na(y2) ? y2 : (not na(y1) ? y1 : na)))
        if not na(baseVal)
            if baseVal <= 0 and current > 0
                cagr := 100.0
                period := "TURNAROUND"
            else if baseVal > 0 and current <= 0
                cagr := -100.0
                period := "DETERIORATING"
            else if baseVal < 0 and current < 0
                cagr := current > baseVal ? 50.0 : -50.0
                period := current > baseVal ? "IMPROVING" : "WORSENING"
            else if baseVal == 0 and current == 0
                cagr := 0.0
                period := "FLAT"
    [cagr, period]

[revCAGR, revPeriod] = growthCAGR(revY0_y, revY1_y, revY2_y, revY3_y, revY4_y)
[fcfCAGR, fcfPeriod] = growthCAGR(fcfY0_y, fcfY1_y, fcfY2_y, fcfY3_y, fcfY4_y)
[eqCAGR, eqPeriod]   = growthCAGR(eqY0_y, eqY1_y, eqY2_y, eqY3_y, eqY4_y)
[epsCAGR, epsPeriod] = growthCAGR(epsY0_y, epsY1_y, epsY2_y, epsY3_y, epsY4_y)

bool revValid = not na(revCAGR)
bool fcfValid = not na(fcfCAGR)
bool eqValid  = not na(eqCAGR)
bool epsValid = not na(epsCAGR)

// Helper for strings
getTrendInfo(float cagr, string period, float threshold) =>
    string tStr = "NO DATA"
    color tCol = color.gray
    if not na(cagr)
        if cagr > threshold
            tStr := "GROWING " + period + " (+" + str.tostring(cagr, "#.#") + "%)"
            tCol := color.green
        else if cagr < -threshold
            tStr := "DECLINING " + period + " (" + str.tostring(cagr, "#.#") + "%)"
            tCol := color.red
        else
            tStr := "STABLE " + period + " (" + str.tostring(cagr, "#.#") + "%)"
            tCol := color.blue
    [tStr, tCol]

[revTrend, revColor] = getTrendInfo(revCAGR, revPeriod, 5)
[fcfTrend, fcfColor] = getTrendInfo(fcfCAGR, fcfPeriod, 5)
[eqTrend, eqColor]   = getTrendInfo(eqCAGR, eqPeriod, 5)

// --- Cyclical & Restructuring ---
bool isCyclicalBoom = false
string cyclicalLabel = ""
color cyclicalColor = color.gray

if revValid and revCAGR > cyclicalThreshold
    isCyclicalBoom := true
    cyclicalLabel := "ðŸ”¥ CYCLICAL BOOM (Rev CAGR " + str.tostring(revCAGR, "#.#") + "%)"
    cyclicalColor := color.yellow
else if not isBank and fcfValid and fcfCAGR > cyclicalThreshold
    isCyclicalBoom := true
    cyclicalLabel := "ðŸ”¥ CYCLICAL BOOM (FCF CAGR " + str.tostring(fcfCAGR, "#.#") + "%)"
    cyclicalColor := color.yellow

float revDropY0Y1 = not na(revY0_y) and not na(revY1_y) and revY1_y > 0 ? ((revY0_y / revY1_y) - 1) * 100 : na
float revDropY1Y2 = not na(revY1_y) and not na(revY2_y) and revY2_y > 0 ? ((revY1_y / revY2_y) - 1) * 100 : na
bool isRestructured = not na(revDropY0Y1) and not na(revDropY1Y2) and revDropY0Y1 < -15 and revDropY1Y2 > -10

string revTrendAdj = revTrend
color revColorAdj  = revColor
if isRestructured
    revTrendAdj := "RESTRUCTURED (use 1Y)"
    revColorAdj := color.orange

// --- Profitability ---
bool isGAAPProfit = nz(netIncome) > 0
bool isCashProfitable = (not isGAAPProfit) and (not na(fcfY0_y) and fcfY0_y > 0) and (not na(epsFY) and epsFY > 0)
bool isProfitable = isGAAPProfit or isCashProfitable

string profitLabel = isGAAPProfit ? "YES (" + str.tostring(netIncome / 1000000, "#.#") + "M)" : (isBank ? "NO" : (isCashProfitable ? "CASH PROF. (" + str.tostring(fcfY0_y / 1000000, "#.#") + "M FCF)" : "NO"))
color profitColor = isGAAPProfit ? color.green : (isBank ? color.red : (isCashProfitable ? color.blue : color.red))

// ============================================================================
// METRIC CALCULATIONS & WARNINGS
// ============================================================================
float dilutionPct = not na(sharesOut) and not na(sharesOutPrev) and sharesOutPrev > 0 ? ((sharesOut / sharesOutPrev) - 1) * 100 : na
bool warnDilution = not na(dilutionPct) and dilutionPct > 5

float niGrowth  = not na(niY0_y) and not na(niY1_y) and niY1_y > 0 and niY0_y > 0 ? ((niY0_y / niY1_y) - 1) * 100 : na
float revGrowth = not na(revY0_y) and not na(revY1_y) and revY1_y > 0 ? ((revY0_y / revY1_y) - 1) * 100 : na
bool warnMarginSqueeze = not isRestructured and not na(niGrowth) and not na(revGrowth) and revGrowth > 0 and niGrowth < revGrowth and (revGrowth - niGrowth) > 5
bool warnRevDecline = not isRestructured and revValid and revCAGR < -5
bool warnEPSLoss = not na(epsFY) and epsFY < 0
bool isInvestmentPhase = revValid and fcfValid and revCAGR > 5 and fcfCAGR < -10

// --- PER SHARE METRICS ---
float fcfPS0 = hasShares and not na(fcfEffective) ? fcfEffective / sharesOut : na
float eqPS0  = hasShares and not na(curEquity)    ? curEquity / sharesOut    : na
float epsPS0 = not na(epsFY) ? epsFY : na
float revPS0 = hasShares and not na(revTTM) ? revTTM / sharesOut : na

// --- MULTIPLES ---
float currentPFCF  = not na(fcfPS0) and fcfPS0 > 0 ? close / fcfPS0 : na
float currentPB    = not na(eqPS0) and eqPS0 > 0 ? close / eqPS0 : na
float currentPE    = not na(epsPS0) and epsPS0 > 0 ? close / epsPS0 : na
float currentPS    = not na(revPS0) and revPS0 > 0 ? close / revPS0 : na

// Active Metric Selection
float activeMetric = 0.0
float activeMultiple = 0.0
string activeMetricName = ""

if valuationModel == "BOOK"
    activeMetric := eqPS0
    activeMultiple := currentPB
    activeMetricName := "P/B"
else if valuationModel == "EARNINGS"
    activeMetric := epsPS0
    activeMultiple := currentPE
    activeMetricName := "P/E"
else if valuationModel == "SALES"
    activeMetric := revPS0
    activeMultiple := currentPS
    activeMetricName := "P/S"
else
    activeMetric := fcfPS0
    activeMultiple := currentPFCF
    activeMetricName := "P/FCF"

// Warnings Logic
bool warnNegativeMetric = activeMetric <= 0
bool warnDeterioration = false
float valWarnThreshold = 0.0

if valuationModel == "BOOK"
    warnDeterioration := eqValid and eqCAGR < -5
    valWarnThreshold := 3.0
else if valuationModel == "EARNINGS" // Utility Logic
    warnDeterioration := epsValid and epsCAGR < -2
    valWarnThreshold := 25.0 // Utilities rarely trade above 25x
else if valuationModel == "SALES" // Growth Spec Logic
    warnDeterioration := revValid and revCAGR < 5 // If growth slows to <5%, P/S is dangerous
    valWarnThreshold := 20.0 // P/S > 20 is dangerous
else
    // Standard FCF
    warnDeterioration := fcfValid and fcfCAGR < -10
    valWarnThreshold := 60.0

bool warnOvervalued = not na(activeMultiple) and activeMultiple > valWarnThreshold
float debtToFCF = not na(totalDebt) and not na(fcfEffective) and fcfEffective > 0 ? totalDebt / fcfEffective : na
bool warnDebtHeavy = (isBank or isUtility) ? false : (not na(debtToFCF) and debtToFCF > 10) 

int warnCount = (warnDilution ? 1 : 0) + (warnNegativeMetric ? 1 : 0) + (warnMarginSqueeze ? 1 : 0) + (warnRevDecline ? 1 : 0) + (warnDeterioration ? 1 : 0) + (warnOvervalued ? 1 : 0) + (warnDebtHeavy ? 1 : 0)
color warnCountColor = warnCount == 0 ? color.green : (warnCount <= 2 ? color.orange : color.red)

string warnText = ""
if warnDilution
    warnText += "DILUTION "
if warnNegativeMetric
    warnText += activeMetricName + "<0 "
if warnOvervalued
    warnText += activeMetricName + ">" + str.tostring(valWarnThreshold, "#") + " "
if warnDeterioration
    warnText += "FUNDAMENTALSâ†“â†“ "
if warnDebtHeavy
    warnText += "DEBT "

if warnCount == 0
    warnText := "ALL CLEAR âœ“"

// Fund Score
int fundScore = (isProfitable ? 1 : 0) + ((isBank ? (not na(curEquity) and curEquity > 0) : (not na(fcfEffective) and fcfEffective > 0)) ? 1 : 0) + ((isBank ? (eqValid and eqCAGR > 5) : (fcfValid and fcfCAGR > 5)) ? 1 : 0) + (revValid and revCAGR > 5 ? 1 : 0) + (not na(epsFY) and epsFY > 0 ? 1 : 0)
string fundGrade = fundScore >= 5 ? "A+" : fundScore >= 4 ? "A" : fundScore >= 3 ? "B" : fundScore >= 2 ? "C" : fundScore >= 1 ? "D" : "F"
color fundGradeColor = fundScore >= 4 ? color.green : fundScore >= 3 ? color.blue : fundScore >= 2 ? color.orange : color.red

// ============================================================================
// SMART FORECASTING
// ============================================================================
decayGrowth(float rawCAGR) =>
    float adj = rawCAGR
    if rawCAGR > 50
        adj := 35.0 + (rawCAGR - 50.0) * 0.25
    else if rawCAGR > 20
        adj := 20.0 + (rawCAGR - 20.0) * 0.5
    adj

float smartGrowth = 0.0
string forecastAdjLabel = ""

if valuationModel == "BOOK" // Bank
    smartGrowth := eqValid ? eqCAGR : 0.0
    forecastAdjLabel := "BOOK"
else if valuationModel == "EARNINGS" // Utility
    // Utilities are stable. Cap growth at 8% conservatively, 12% max.
    smartGrowth := epsValid ? math.min(epsCAGR, 10.0) : 0.0
    forecastAdjLabel := "REGULATED"
else if valuationModel == "SALES" // Unprofitable Growth
    // Sales growth needs heavy decay for P/S models
    smartGrowth := revValid ? decayGrowth(revCAGR) : 0.0
    forecastAdjLabel := "REVENUE"
else // Standard FCF
    if isRestructured
        smartGrowth := 0.0
    else if isCyclicalBoom
        smartGrowth := decayGrowth(fcfCAGR) * 0.7
        forecastAdjLabel := "CYCL DECAY"
    else
        smartGrowth := fcfValid ? decayGrowth(fcfCAGR) : 0.0

float finalGrowthRate = math.max(-0.4, math.min(smartGrowth / 100.0, 0.4))
bool forecastValid = not na(activeMultiple) and activeMetric > 0

// Multiple Normalization
float forecastMultiple = activeMultiple

if valuationModel == "EARNINGS" and activeMultiple > 20
    // Cap Utility P/E forecast
    forecastMultiple := (activeMultiple + 15.0) / 2.0 
else if valuationModel == "SALES" and activeMultiple > 15
    // Cap P/S forecast aggressively
    forecastMultiple := (activeMultiple + 5.0) / 2.0
else if valuationModel == "BOOK" and activeMultiple > 2.0
    forecastMultiple := (activeMultiple + 1.0) / 2.0
else if activeMultiple > 50
    forecastMultiple := (activeMultiple + 30.0) / 2.0

float metricPerShareFwd = forecastValid ? activeMetric * (1 + finalGrowthRate) : na
float priceBear = forecastValid ? metricPerShareFwd * forecastMultiple * 0.70 : na
float priceFair = forecastValid ? metricPerShareFwd * forecastMultiple * 1.00 : na
float priceBull = forecastValid ? metricPerShareFwd * forecastMultiple * 1.30 : na

float upsideBear = forecastValid and close > 0 ? ((priceBear / close) - 1) * 100 : na
float upsideFair = forecastValid and close > 0 ? ((priceFair / close) - 1) * 100 : na
float upsideBull = forecastValid and close > 0 ? ((priceBull / close) - 1) * 100 : na

// ============================================================================
// SECTOR ROTATION & TECHNICAL CALCULATIONS
// ============================================================================
scorePhases(float techP, float finP, float healthP, float energyP, float staplesP, float utilP) =>
    float early = 0.0
    float mid = 0.0
    float late = 0.0
    float defense = 0.0
    if finP > techP
        early += 1
    if finP > energyP
        early += 1
    if finP > staplesP
        early += 1
    if techP > finP
        mid += 1
    if techP > energyP
        mid += 1
    if techP > staplesP
        mid += 1
    if techP > utilP
        mid += 1
    if energyP > techP
        late += 1
    if energyP > finP
        late += 1
    if energyP > staplesP
        late += 1
    if staplesP > techP
        defense += 1
    if utilP > techP
        defense += 1
    if healthP > techP
        defense += 1
    if staplesP > energyP
        defense += 1
    [early, mid, late, defense]

isSectorInPhase(string sector, string phase) =>
    bool result = false
    if phase == "EARLY RECOVERY"
        result := sector == "Finance" or sector == "Financial" or sector == "Real Estate" or sector == "Consumer Cyclical" or sector == "Consumer Durables" or sector == "Retail Trade" or sector == "Transportation"
    else if phase == "MID EXPANSION"
        result := sector == "Technology" or sector == "Technology Services" or sector == "Electronic Technology" or sector == "Industrials" or sector == "Industrial Services" or sector == "Producer Manufacturing" or sector == "Communication Services" or sector == "Communications" or sector == "Transportation"
    else if phase == "LATE EXPANSION"
        result := sector == "Energy" or sector == "Energy Minerals" or sector == "Basic Materials" or sector == "Non-Energy Minerals" or sector == "Process Industries" or sector == "Industrials" or sector == "Industrial Services" or sector == "Producer Manufacturing" or sector == "Transportation"
    else if phase == "DEFENSIVE"
        result := sector == "Healthcare" or sector == "Health Technology" or sector == "Health Services" or sector == "Consumer Defensive" or sector == "Consumer Non-Durables" or sector == "Consumer Services" or sector == "Utilities" or sector == "Distribution Services"
    result

calcPerf(float currentVal, float pastVal) =>
    not na(currentVal) and not na(pastVal) and pastVal > 0 ? (currentVal / pastVal - 1) * 100 : na

float techPerfL    = calcPerf(techClose, techClose[rotationLookback])
float finPerfL     = calcPerf(finClose, finClose[rotationLookback])
float healthPerfL  = calcPerf(healthClose, healthClose[rotationLookback])
float energyPerfL  = calcPerf(energyClose, energyClose[rotationLookback])
float staplesPerfL = calcPerf(staplesClose, staplesClose[rotationLookback])
float utilPerfL    = calcPerf(utilClose, utilClose[rotationLookback])
bool rotDataValid = not na(techPerfL) and not na(finPerfL) and not na(healthPerfL) and not na(energyPerfL) and not na(staplesPerfL) and not na(utilPerfL)

int shortLookback = 20
float techPerfS    = calcPerf(techClose, techClose[shortLookback])
float finPerfS     = calcPerf(finClose, finClose[shortLookback])
float healthPerfS  = calcPerf(healthClose, healthClose[shortLookback])
float energyPerfS  = calcPerf(energyClose, energyClose[shortLookback])
float staplesPerfS = calcPerf(staplesClose, staplesClose[shortLookback])
float utilPerfS    = calcPerf(utilClose, utilClose[shortLookback])
bool rotShortValid = not na(techPerfS) and not na(finPerfS) and not na(healthPerfS) and not na(energyPerfS) and not na(staplesPerfS) and not na(utilPerfS)

[earlyScoreL, midScoreL, lateScoreL, defenseScoreL] = scorePhases(techPerfL, finPerfL, healthPerfL, energyPerfL, staplesPerfL, utilPerfL)
[earlyScoreS, midScoreS, lateScoreS, defenseScoreS] = scorePhases(techPerfS, finPerfS, healthPerfS, energyPerfS, staplesPerfS, utilPerfS)

determinePhase(float earlyS, float midS, float lateS, float defS) =>
    float maxS = math.max(math.max(earlyS, midS), math.max(lateS, defS))
    string phase = "NO DATA"
    if maxS == midS and midS > 0
        phase := "MID EXPANSION"
    else if maxS == earlyS and earlyS > 0
        phase := "EARLY RECOVERY"
    else if maxS == lateS and lateS > 0
        phase := "LATE EXPANSION"
    else if maxS == defS and defS > 0
        phase := "DEFENSIVE"
    phase

string longPhase  = rotDataValid  ? determinePhase(earlyScoreL, midScoreL, lateScoreL, defenseScoreL) : "NO DATA"
string shortPhase = rotShortValid ? determinePhase(earlyScoreS, midScoreS, lateScoreS, defenseScoreS) : "NO DATA"

bool isTransitioning = rotDataValid and rotShortValid and longPhase != shortPhase and shortPhase != "NO DATA"
string activePhase = rotShortValid ? shortPhase : longPhase

string cyclePhase = "NO DATA"
color cycleColor = color.gray
string nextPhase = "NO DATA"
color nextColor = color.gray
string transitionLabel = ""

if rotDataValid
    if activePhase == "MID EXPANSION"
        cyclePhase := isTransitioning ? "Â» MID EXPANSION" : "MID EXPANSION"
        cycleColor := color.blue
        nextPhase := "LATE EXPANSION"
        nextColor := color.orange
    else if activePhase == "EARLY RECOVERY"
        cyclePhase := isTransitioning ? "Â» EARLY RECOVERY" : "EARLY RECOVERY"
        cycleColor := color.green
        nextPhase := "MID EXPANSION"
        nextColor := color.blue
    else if activePhase == "LATE EXPANSION"
        cyclePhase := isTransitioning ? "Â» LATE EXPANSION" : "LATE EXPANSION"
        cycleColor := color.orange
        nextPhase := "DEFENSIVE"
        nextColor := color.red
    else if activePhase == "DEFENSIVE"
        cyclePhase := isTransitioning ? "Â» DEFENSIVE" : "DEFENSIVE"
        cycleColor := color.red
        nextPhase := "EARLY RECOVERY"
        nextColor := color.green
    if isTransitioning
        transitionLabel := " (was " + longPhase + ")"

bool isFavoredSector = isSectorInPhase(stockSector, activePhase)
bool isNextFavored   = isSectorInPhase(stockSector, nextPhase)
string sectorFitLabel = "NO DATA"
color sectorFitColor = color.gray
if rotDataValid
    if isFavoredSector and not isTransitioning
        sectorFitLabel := "FAVORED"
        sectorFitColor := color.green
    else if isFavoredSector and isTransitioning
        sectorFitLabel := "ROTATING IN"
        sectorFitColor := color.green
    else if isNextFavored
        sectorFitLabel := "SMART MONEY"
        sectorFitColor := color.blue
    else if isTransitioning and not isFavoredSector and not isNextFavored
        sectorFitLabel := "ROTATING OUT"
        sectorFitColor := color.orange
    else
        sectorFitLabel := "OUT OF FAVOR"
        sectorFitColor := color.red

float ma50        = ta.sma(close, smaFast)
float ma200       = ta.sma(close, smaSlow)
float avgVol      = ta.sma(volume, 50)
float highestHigh = ta.highest(high, baseLookback)
float lowestLow   = ta.lowest(low, baseLookback)
float atrVal      = ta.atr(atrLen)
float rsiVal      = ta.rsi(close, rsiLen)

float trueRange  = ta.tr(true)
float dmPlus     = math.max(high - high[1], 0)
float dmMinus    = math.max(low[1] - low, 0)
float dmPClean   = dmPlus > dmMinus ? dmPlus : 0.0
float dmMClean   = dmMinus > dmPlus ? dmMinus : 0.0
float smTR       = ta.rma(trueRange, adxLen)
float smDMPlus   = ta.rma(dmPClean, adxLen)
float smDMMinus  = ta.rma(dmMClean, adxLen)
float diPlus     = smTR > 0 ? (smDMPlus / smTR) * 100 : 0.0
float diMinus    = smTR > 0 ? (smDMMinus / smTR) * 100 : 0.0
float diSum      = diPlus + diMinus
float dx         = diSum > 0 ? math.abs(diPlus - diMinus) / diSum * 100 : 0.0
float adxVal     = ta.rma(dx, adxLen)
bool isTrending  = adxVal > adxThreshold

float prevClose     = close[20]
float prevCompClose = compClose[20]
bool rsDataValid    = not na(compClose) and not na(prevCompClose) and not na(prevClose) and prevClose > 0 and prevCompClose > 0
float symbolPerf    = rsDataValid ? (close - prevClose) / prevClose : 0.0
float compPerf      = rsDataValid ? (compClose - prevCompClose) / prevCompClose : 0.0
bool isRSStrong     = rsDataValid and symbolPerf > compPerf

float prevC          = nz(close[1], close)
float logReturn      = prevC > 0 and close > 0 ? math.log(close / prevC) : 0.0
float logStdDev      = ta.stdev(logReturn, probLookback)
float expectedMovePct = logStdDev * math.sqrt(5) * 100
float expectedMove    = close * logStdDev * math.sqrt(5)

float distToMA50 = close - ma50
float warnProb   = na(distToMA50) ? na : (distToMA50 > 0 ? math.min(100, (expectedMove / distToMA50) * 50) : 100.0)
float distToHigh = highestHigh - close
float entryProb  = na(distToHigh) ? na : (distToHigh > 0 ? math.min(100, (expectedMove / distToHigh) * 50) : 0.0)

bool ma50Rising  = ma50 > ma50[5]
float maxVol5    = ta.highest(volume, 5)
bool isHighVol   = maxVol5 > avgVol * volThreshold
string volStatus = "STABLE"
color volColor   = color.blue
if isHighVol
    if close > close[1] and close > ma50
        volStatus := "ACCUMULATION"
        volColor := color.green
    else
        volStatus := "DISTRIBUTION"
        volColor := color.red

float distToMA50Pct  = ma50 > 0  ? ((close - ma50) / ma50) * 100   : na
float distToMA200Pct = ma200 > 0 ? ((close - ma200) / ma200) * 100 : na
color ma50Color = ma50 > ma200 ? color.blue : color.orange

float stopATR   = close - (atrVal * 2)
float stopBase  = lowestLow
float stopLevel = math.max(stopATR, stopBase)
float riskPerShare   = close - stopLevel
float rewardPerShare = highestHigh - close
float rrRatio        = riskPerShare > 0 ? rewardPerShare / riskPerShare : na

bool rawEntry   = ta.crossover(close, highestHigh[1]) and volume > avgVol * 1.2 and close > ma50 and close > ma200
bool rawWarning = ta.crossunder(close, ma50) and volume > avgVol * 1.1
bool filteredEntry   = rawEntry and isProfitable and isTrending and rsiVal < rsiOB and weeklyBullish
bool filteredWarning = rawWarning

var int lastEntryBar   = na
var int lastWarningBar = na
bool entryCooldownOk   = na(lastEntryBar)   or (bar_index - lastEntryBar)   >= cooldownBars
bool warningCooldownOk = na(lastWarningBar) or (bar_index - lastWarningBar) >= cooldownBars
bool entrySignal   = filteredEntry   and entryCooldownOk
bool warningSignal = filteredWarning and warningCooldownOk
if entrySignal
    lastEntryBar := bar_index
if warningSignal
    lastWarningBar := bar_index

// ============================================================================
// VISUALIZATION
// ============================================================================
bool isBase = (highestHigh - lowestLow) < lowestLow * 0.15
bgcolor(isBase ? color.new(color.gray, 90) : na)

plot(ma50, color=ma50Rising ? ma50Color : color.red, linewidth=2, title="50 SMA")
plot(ma200, color=color.white, linewidth=3, title="200 SMA")
plot(stopLevel, color=color.new(color.red, 60), linewidth=1, style=plot.style_cross, title="Suggested Stop")

plot(showForecast and forecastValid ? priceBull : na, color=color.new(color.green, 40), linewidth=1, style=plot.style_line, title="Bull Target (1Y)")
plot(showForecast and forecastValid ? priceFair : na, color=color.new(color.yellow, 40), linewidth=2, style=plot.style_line, title="Fair Value (1Y)")
plot(showForecast and forecastValid ? priceBear : na, color=color.new(color.red, 40),   linewidth=1, style=plot.style_line, title="Bear Target (1Y)")

plotshape(entrySignal,   title="ENTRY",   style=shape.labelup,   location=location.belowbar, color=color.green, text="ENTRY",   textcolor=color.white, size=size.small)
plotshape(warningSignal, title="WARNING", style=shape.labeldown, location=location.abovebar, color=color.red,   text="WARNING", textcolor=color.white, size=size.small)

// ============================================================================
// DASHBOARD
// ============================================================================
var table masterTable = table.new(position.top_right, 2, 32, bgcolor=color.new(color.black, 70), border_width=1, border_color=color.gray)

if barstate.islast
    color wColor  = warnProb > 70 ? color.red : (warnProb > 40 ? color.orange : color.green)
    color eColor  = entryProb > 70 ? color.green : (entryProb > 40 ? color.orange : color.red)
    color rsColor = isRSStrong ? color.green : color.red

    int row = 0

    table.cell(masterTable, 0, row, "âš  WARNINGS", text_color=color.white)
    table.cell(masterTable, 1, row, str.tostring(warnCount) + "/9: " + warnText, bgcolor=warnCountColor, text_color=color.white, text_size=size.small)
    row += 1

    table.cell(masterTable, 0, row, "FUND. GRADE", text_color=color.white)
    table.cell(masterTable, 1, row, fundGrade + " (" + str.tostring(fundScore) + "/5)", bgcolor=fundGradeColor, text_color=color.white)
    row += 1

    table.cell(masterTable, 0, row, "GAAP PROFIT", text_color=color.white)
    table.cell(masterTable, 1, row, profitLabel, bgcolor=profitColor, text_color=color.white)
    row += 1

    color epsColor = not na(epsFY) and epsFY > 0 ? color.green : color.red
    table.cell(masterTable, 0, row, "EPS (TTM)", text_color=color.white)
    table.cell(masterTable, 1, row, not na(epsFY) ? str.tostring(epsFY, "#.##") : "N/A", bgcolor=not na(epsFY) ? epsColor : color.gray, text_color=color.white)
    row += 1

    table.cell(masterTable, 0, row, "REVENUE", text_color=color.white)
    table.cell(masterTable, 1, row, revTrendAdj, bgcolor=revColorAdj, text_color=color.white)
    row += 1

    // DYNAMIC ROW: Model Specific Trend
    string trendTitle = "FCF TREND"
    string trendVal = fcfTrend
    color trendCol = fcfColor
    if valuationModel == "BOOK"
        trendTitle := "BOOK VAL TREND"
        trendVal := eqTrend
        trendCol := eqColor
    else if valuationModel == "EARNINGS"
        trendTitle := "EPS TREND"
        trendVal := str.tostring(epsCAGR, "#.#") + "% (Regulated)"
        trendCol := color.blue
    else if valuationModel == "SALES"
        trendTitle := "REVENUE TREND"
        trendVal := revTrend
        trendCol := revColor

    table.cell(masterTable, 0, row, trendTitle, text_color=color.white)
    table.cell(masterTable, 1, row, trendVal, bgcolor=trendCol, text_color=color.white)
    row += 1

    if isRestructured
        table.cell(masterTable, 0, row, "ðŸ“‹ PHASE", text_color=color.white)
        table.cell(masterTable, 1, row, "RESTRUCTURED / SPINOFF", bgcolor=color.orange, text_color=color.white)
        row += 1
    else if isCyclicalBoom
        table.cell(masterTable, 0, row, "ðŸ”¥ PHASE", text_color=color.white)
        table.cell(masterTable, 1, row, cyclicalLabel, bgcolor=cyclicalColor, text_color=color.white, text_size=size.small)
        row += 1

    // DYNAMIC ROW: Valuation Output
    color valNowColor = color.gray
    string valLabel = str.tostring(activeMultiple, "#.#") + "x"
    if warnOvervalued
        valLabel += " âš  HIGH"
        valNowColor := color.orange
    else
        valNowColor := color.green

    table.cell(masterTable, 0, row, activeMetricName + " (NOW)", text_color=color.white)
    table.cell(masterTable, 1, row, valLabel, bgcolor=valNowColor, text_color=color.white)
    row += 1

    string forecastBasisText = "N/A"
    color basisColor = color.gray
    if not forecastValid
        forecastBasisText := "NO FORECAST (" + activeMetricName + " < 0)"
        basisColor := color.red
    else
        string growthLabel = (finalGrowthRate >= 0 ? "+" : "") + str.tostring(finalGrowthRate * 100, "#.#") + "%"
        if forecastAdjLabel != ""
            growthLabel += " (" + forecastAdjLabel + ")"
        
        string multLabel = "NORM " + str.tostring(forecastMultiple, "#.#") + "x"
        forecastBasisText := growthLabel + " | " + multLabel
        basisColor := forecastAdjLabel != "" ? color.orange : color.gray

    table.cell(masterTable, 0, row, "FORECAST (" + activeMetricName + ")", text_color=color.white)
    table.cell(masterTable, 1, row, forecastBasisText, bgcolor=basisColor, text_color=color.white, text_size=size.small)
    row += 1

    color bearColor = not na(upsideBear) ? (upsideBear > 0 ? color.green : color.red) : color.gray
    color fairColor = not na(upsideFair) ? (upsideFair > 0 ? color.green : color.red) : color.gray
    color bullColor = not na(upsideBull) ? (upsideBull > 0 ? color.green : color.red) : color.gray

    table.cell(masterTable, 0, row, "1Y BEAR", text_color=color.white)
    table.cell(masterTable, 1, row, forecastValid ? str.tostring(priceBear, "#.##") + " (" + str.tostring(upsideBear, "#.#") + "%)" : "N/A", bgcolor=bearColor, text_color=color.white)
    row += 1

    table.cell(masterTable, 0, row, "1Y FAIR", text_color=color.white)
    table.cell(masterTable, 1, row, forecastValid ? str.tostring(priceFair, "#.##") + " (" + str.tostring(upsideFair, "#.#") + "%)" : "N/A", bgcolor=fairColor, text_color=color.white)
    row += 1

    table.cell(masterTable, 0, row, "1Y BULL", text_color=color.white)
    table.cell(masterTable, 1, row, forecastValid ? str.tostring(priceBull, "#.##") + " (" + str.tostring(upsideBull, "#.#") + "%)" : "N/A", bgcolor=bullColor, text_color=color.white)
    row += 1

    table.cell(masterTable, 0, row, "TREND", text_color=color.white)
    table.cell(masterTable, 1, row, ma50Rising ? "BULLISH" : "BEARISH", bgcolor=ma50Rising ? color.green : color.red, text_color=color.white)
    row += 1

    table.cell(masterTable, 0, row, "WEEKLY TREND", text_color=color.white)
    table.cell(masterTable, 1, row, weeklyBullish ? "BULLISH" : "BEARISH", bgcolor=weeklyBullish ? color.green : color.red, text_color=color.white)
    row += 1

    color adxColor = isTrending ? color.green : color.gray
    table.cell(masterTable, 0, row, "ADX (TREND)", text_color=color.white)
    table.cell(masterTable, 1, row, str.tostring(adxVal, "#.#") + (isTrending ? " TRENDING" : " CHOPPY"), bgcolor=adxColor, text_color=color.white)
    row += 1

    color rsiColor  = rsiVal > rsiOB ? color.red : (rsiVal < 30 ? color.green : color.blue)
    string rsiLabel = rsiVal > rsiOB ? " OVERBOUGHT" : (rsiVal < 30 ? " OVERSOLD" : "")
    table.cell(masterTable, 0, row, "RSI", text_color=color.white)
    table.cell(masterTable, 1, row, str.tostring(rsiVal, "#.#") + rsiLabel, bgcolor=rsiColor, text_color=color.white)
    row += 1

    table.cell(masterTable, 0, row, "VOLUME", text_color=color.white)
    table.cell(masterTable, 1, row, volStatus, bgcolor=volColor, text_color=color.white)
    row += 1

    table.cell(masterTable, 0, row, "RS vs " + compSymbol, text_color=color.white)
    table.cell(masterTable, 1, row, rsDataValid ? (isRSStrong ? "STRONGER" : "WEAKER") : "NO DATA", bgcolor=rsDataValid ? rsColor : color.gray, text_color=color.white)
    row += 1

    table.cell(masterTable, 0, row, "CYCLE PHASE", text_color=color.white)
    string cycleDisplay = isTransitioning ? cyclePhase + transitionLabel : cyclePhase
    table.cell(masterTable, 1, row, cycleDisplay, bgcolor=cycleColor, text_color=color.white, text_size=size.small)
    row += 1

    string sectorDisplay = stockSector != "" ? stockSector : "UNKNOWN"
    table.cell(masterTable, 0, row, "SECTOR FIT", text_color=color.white)
    table.cell(masterTable, 1, row, sectorFitLabel + " (" + sectorDisplay + ")", bgcolor=sectorFitColor, text_color=color.white, text_size=size.small)
    row += 1

    table.cell(masterTable, 0, row, "NEXT PHASE", text_color=color.white)
    table.cell(masterTable, 1, row, nextPhase, bgcolor=nextColor, text_color=color.white)
    row += 1

    table.cell(masterTable, 0, row, "PROB. WARNING (5d)", text_color=color.white)
    table.cell(masterTable, 1, row, not na(warnProb) ? str.tostring(warnProb, "#.##") + "%" : "N/A", bgcolor=wColor, text_color=color.white)
    row += 1

    table.cell(masterTable, 0, row, "PROB. ENTRY (5d)", text_color=color.white)
    table.cell(masterTable, 1, row, not na(entryProb) ? str.tostring(entryProb, "#.##") + "%" : "N/A", bgcolor=eColor, text_color=color.white)
    row += 1

    color d50Color = not na(distToMA50Pct) ? (distToMA50Pct > 0 ? color.green : color.red) : color.gray
    table.cell(masterTable, 0, row, "DIST. TO MA50", text_color=color.white)
    table.cell(masterTable, 1, row, not na(distToMA50Pct) ? str.tostring(distToMA50Pct, "#.##") + "%" : "N/A", bgcolor=d50Color, text_color=color.white)
    row += 1

    color d200Color = not na(distToMA200Pct) ? (distToMA200Pct > 0 ? color.green : color.red) : color.gray
    table.cell(masterTable, 0, row, "DIST. TO MA200", text_color=color.white)
    table.cell(masterTable, 1, row, not na(distToMA200Pct) ? str.tostring(distToMA200Pct, "#.##") + "%" : "N/A", bgcolor=d200Color, text_color=color.white)
    row += 1

    table.cell(masterTable, 0, row, "STOP / R:R", text_color=color.white)
    string rrText = not na(rrRatio) and rrRatio > 0 ? str.tostring(stopLevel, "#.##") + " | 1:" + str.tostring(rrRatio, "#.#") : str.tostring(stopLevel, "#.##") + " | N/A"
    color rrColor = not na(rrRatio) and rrRatio >= 2 ? color.green : (not na(rrRatio) and rrRatio >= 1 ? color.orange : color.red)
    table.cell(masterTable, 1, row, rrText, bgcolor=rrColor, text_color=color.white)
    row += 1